/**
 * {{connectorName}} - {{integrationName}} Integration Connector
 * {{description}}
 */

import { BaseService } from '@/lib/base/base-service'
import { {{integrationName}}Auth } from './auth'
import { {{integrationName}}ApiClient } from './api-client'
import { transformProduct, transformCustomer, transformOrder } from './transformers'
import type { 
  {{integrationName}}Config,
  {{integrationName}}Product,
  {{integrationName}}Customer,
  {{integrationName}}Order,
  SyncResult
} from '@/types/{{kebabName}}.types'

export class {{connectorName}} extends BaseService {
  private auth: {{integrationName}}Auth
  private client: {{integrationName}}ApiClient
  private config: {{integrationName}}Config

  constructor(config: {{integrationName}}Config) {
    super({
      serviceName: '{{connectorName}}',
      maxRetries: 3,
      retryDelay: 2000,
      circuitBreakerEnabled: true,
      timeoutMs: 30000,
      monitoring: true
    })

    if (!config.{{#if (eq type 'oauth')}}clientId || !config.clientSecret{{else}}apiKey{{/if}}) {
      throw new Error('{{integrationName}} configuration is required')
    }

    this.config = config
    this.auth = new {{integrationName}}Auth(config)
    this.client = new {{integrationName}}ApiClient(config, this.auth)
  }

  /**
   * Test connection to {{integrationName}}
   */
  async testConnection(): Promise<boolean> {
    return this.execute(async () => {
      this.log('info', 'Testing {{integrationName}} connection')
      
      try {
        await this.auth.authenticate()
        await this.client.get('/ping') // or appropriate health check endpoint
        
        this.log('info', '{{integrationName}} connection successful')
        return true
      } catch (error) {
        this.log('error', '{{integrationName}} connection failed', error)
        return false
      }
    })
  }

  /**
   * Sync all products from {{integrationName}}
   */
  async syncProducts(): Promise<SyncResult> {
    return this.execute(async () => {
      this.log('info', 'Starting {{integrationName}} products sync')
      
      const result: SyncResult = {
        success: false,
        entityType: 'product',
        processed: 0,
        created: 0,
        updated: 0,
        errors: 0,
        errorDetails: [],
        startedAt: new Date().toISOString(),
        completedAt: ''
      }

      try {
        const products = await this.getProducts()
        result.processed = products.length

        for (const product of products) {
          try {
            const transformedProduct = transformProduct(product)
            
            // TODO: Save to database
            // const existing = await productRepository.findByExternalId(product.id)
            // if (existing) {
            //   await productRepository.update(existing.id, transformedProduct)
            //   result.updated++
            // } else {
            //   await productRepository.create(transformedProduct)
            //   result.created++
            // }
            
            result.created++ // Temporary for testing
          } catch (error) {
            result.errors++
            result.errorDetails?.push(`Product ${product.id}: ${error.message}`)
            this.log('error', `Failed to sync product ${product.id}`, error)
          }
        }

        result.success = result.errors === 0
        result.completedAt = new Date().toISOString()
        
        this.recordMetric('{{kebabName}}.products.synced', {
          processed: result.processed,
          created: result.created,
          updated: result.updated,
          errors: result.errors
        })

        this.log('info', 'Products sync completed', result)
        return result

      } catch (error) {
        result.success = false
        result.completedAt = new Date().toISOString()
        this.log('error', 'Products sync failed', error)
        throw error
      }
    })
  }

  /**
   * Sync all customers from {{integrationName}}
   */
  async syncCustomers(): Promise<SyncResult> {
    return this.execute(async () => {
      this.log('info', 'Starting {{integrationName}} customers sync')
      
      const result: SyncResult = {
        success: false,
        entityType: 'customer',
        processed: 0,
        created: 0,
        updated: 0,
        errors: 0,
        errorDetails: [],
        startedAt: new Date().toISOString(),
        completedAt: ''
      }

      try {
        const customers = await this.getCustomers()
        result.processed = customers.length

        for (const customer of customers) {
          try {
            const transformedCustomer = transformCustomer(customer)
            
            // TODO: Save to database
            result.created++ // Temporary for testing
          } catch (error) {
            result.errors++
            result.errorDetails?.push(`Customer ${customer.id}: ${error.message}`)
            this.log('error', `Failed to sync customer ${customer.id}`, error)
          }
        }

        result.success = result.errors === 0
        result.completedAt = new Date().toISOString()
        
        this.recordMetric('{{kebabName}}.customers.synced', result)
        this.log('info', 'Customers sync completed', result)
        return result

      } catch (error) {
        result.success = false
        result.completedAt = new Date().toISOString()
        this.log('error', 'Customers sync failed', error)
        throw error
      }
    })
  }

  /**
   * Get products from {{integrationName}}
   */
  async getProducts(page = 1, limit = 100): Promise<{{integrationName}}Product[]> {
    return this.execute(async () => {
      this.log('info', `Fetching {{integrationName}} products (page ${page})`)
      
      const response = await this.client.get('/products', {
        page,
        limit,
        // Add other query parameters as needed
      })

      return response.data || []
    })
  }

  /**
   * Get customers from {{integrationName}}
   */
  async getCustomers(page = 1, limit = 100): Promise<{{integrationName}}Customer[]> {
    return this.execute(async () => {
      this.log('info', `Fetching {{integrationName}} customers (page ${page})`)
      
      const response = await this.client.get('/customers', {
        page,
        limit
      })

      return response.data || []
    })
  }

  /**
   * Get orders from {{integrationName}}
   */
  async getOrders(page = 1, limit = 100): Promise<{{integrationName}}Order[]> {
    return this.execute(async () => {
      this.log('info', `Fetching {{integrationName}} orders (page ${page})`)
      
      const response = await this.client.get('/orders', {
        page,
        limit
      })

      return response.data || []
    })
  }

  {{#if sync}}
  /**
   * Sync specific product by ID
   */
  async syncProduct(productId: string): Promise<void> {
    return this.execute(async () => {
      this.log('info', `Syncing {{integrationName}} product: ${productId}`)
      
      const product = await this.client.get(`/products/${productId}`)
      const transformedProduct = transformProduct(product)
      
      // TODO: Save to database
      this.log('info', `Product ${productId} synced successfully`)
    })
  }

  /**
   * Sync specific customer by ID
   */
  async syncCustomer(customerId: string): Promise<void> {
    return this.execute(async () => {
      this.log('info', `Syncing {{integrationName}} customer: ${customerId}`)
      
      const customer = await this.client.get(`/customers/${customerId}`)
      const transformedCustomer = transformCustomer(customer)
      
      // TODO: Save to database
      this.log('info', `Customer ${customerId} synced successfully`)
    })
  }

  /**
   * Sync specific order by ID
   */
  async syncOrder(orderId: string): Promise<void> {
    return this.execute(async () => {
      this.log('info', `Syncing {{integrationName}} order: ${orderId}`)
      
      const order = await this.client.get(`/orders/${orderId}`)
      const transformedOrder = transformOrder(order)
      
      // TODO: Save to database
      this.log('info', `Order ${orderId} synced successfully`)
    })
  }
  {{/if}}

  {{#if webhook}}
  /**
   * Handle product deletion from webhook
   */
  async handleProductDeletion(productId: string): Promise<void> {
    return this.execute(async () => {
      this.log('info', `Handling {{integrationName}} product deletion: ${productId}`)
      
      // TODO: Soft delete or mark as inactive in database
      this.log('info', `Product ${productId} deletion handled`)
    })
  }
  {{/if}}

  /**
   * Health check for {{integrationName}} integration
   */
  protected async runHealthCheck(): Promise<boolean> {
    try {
      return await this.testConnection()
    } catch (error) {
      this.log('error', '{{integrationName}} health check failed', error)
      return false
    }
  }
}