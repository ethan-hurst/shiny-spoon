# PRP-002: Supabase Setup and Database Schema

## Goal
Set up Supabase project infrastructure and create the foundational database schema with multi-tenant architecture, implementing Row Level Security (RLS) policies on all tables, creating necessary indexes for performance, and generating TypeScript types for type-safe database access throughout the application.

## Why
- **Business Value**: Secure, scalable data architecture prevents data breaches and enables growth from 1 to 1000+ customers
- **Integration**: Every feature depends on the database schema - this blocks all other development
- **Problems Solved**: Eliminates data isolation concerns, provides type safety, enables real-time features, ensures ACID compliance for financial data

## What
Create Supabase project (local or cloud), design and implement initial database schema with organizations, users, products, warehouses, and inventory tables, implement comprehensive RLS policies for multi-tenancy, set up development seed data, and establish database access patterns.

### Success Criteria
- [ ] Supabase project accessible from Next.js application
- [ ] All core tables created with proper relationships
- [ ] RLS policies prevent cross-organization data access
- [ ] TypeScript types generated and no type errors
- [ ] Seed script creates realistic test data
- [ ] Database functions for user profile creation work
- [ ] Indexes improve query performance for common patterns
- [ ] Migration files are idempotent and reversible

## All Needed Context

### Documentation & References
```yaml
- url: https://supabase.com/docs/guides/database/tables
  why: Table creation, constraints, indexes, RLS policies
  section: Row Level Security deep dive
  critical: Enable RLS on every table for security
  
- url: https://supabase.com/docs/guides/database/postgres/triggers
  why: Trigger functions for automated workflows
  section: Creating user profiles on signup
  
- file: ARCHITECTURE.md
  why: Database schema design decisions, relationships
  
- file: docs/technical/supabase-integration-guide.md
  why: Our specific patterns for RLS, migrations, types
  
- url: https://supabase.com/docs/guides/cli/local-development
  why: Local Supabase setup for development
  critical: Use migrations for version control

- url: https://www.postgresql.org/docs/current/indexes.html
  why: Index strategies for our query patterns
  section: Multicolumn indexes, partial indexes

- docfile: docs/product/PRD.md
  why: Understanding data relationships and business rules
```

### Current Codebase Tree
```bash
truthsource/
├── app/
├── components/
├── lib/
│   └── utils.ts
├── types/
└── package.json          # From PRP-001
```

### Desired Codebase Tree
```bash
truthsource/
├── app/
├── components/
├── lib/
│   ├── supabase/
│   │   ├── client.ts           # Browser client
│   │   ├── server.ts           # Server client  
│   │   ├── admin.ts            # Admin client (service role)
│   │   └── middleware.ts       # Auth middleware
│   └── utils.ts
├── types/
│   └── database.types.ts       # Generated from schema
├── supabase/
│   ├── config.toml             # Local config
│   ├── migrations/
│   │   └── 001_initial_schema.sql
│   ├── functions/              # Edge functions (empty for now)
│   └── seed.sql               # Development data
├── .env.local                  # With Supabase credentials
└── package.json
```

### Known Gotchas
```typescript
// CRITICAL: RLS must be enabled on EVERY table or data leaks occur
// Example: ALTER TABLE products ENABLE ROW LEVEL SECURITY;
// Example: Policies must check organization_id, not user_id
// Example: UUID primary keys for all tables (no serial IDs)
// Example: Timestamps should be TIMESTAMPTZ for timezone handling
// Example: Use gen_random_uuid() not uuid_generate_v4()
// Example: Migrations must be idempotent (IF NOT EXISTS)
// Example: Service role key bypasses RLS - use carefully
// Example: Composite unique constraints for multi-tenant data
```

## Implementation Blueprint

### Data Models and Structure
```sql
-- Database schema design
-- Organizations: Root of multi-tenancy
-- User Profiles: Links auth.users to organizations  
-- Products: Catalog of items to track
-- Warehouses: Physical locations
-- Inventory: Junction table with quantity data

-- Key relationships:
-- 1 Organization has many Users (user_profiles)
-- 1 Organization has many Products
-- 1 Organization has many Warehouses  
-- 1 Product + 1 Warehouse = 1 Inventory record

-- RLS Pattern for all tables:
-- SELECT: organization_id IN (user's orgs)
-- INSERT: organization_id matches user's org
-- UPDATE: organization_id matches user's org  
-- DELETE: Usually forbidden, use soft delete
```

### Task List

```yaml
Task 1: Set Up Supabase Project
CHOOSE one:
  - LOCAL: pnpm supabase init && pnpm supabase start
  - CLOUD: Create project at supabase.com
CONFIGURE .env.local:
  - Add NEXT_PUBLIC_SUPABASE_URL
  - Add NEXT_PUBLIC_SUPABASE_ANON_KEY
  - Add SUPABASE_SERVICE_ROLE_KEY

Task 2: Create Initial Migration
CREATE supabase/migrations/001_initial_schema.sql:
  - Enable extensions (uuid-ossp if needed)
  - Create organizations table
  - Create user_profiles table
  - Create products table
  - Create warehouses table
  - Create inventory table
  - Add all foreign key constraints
  - Create indexes for performance

Task 3: Implement RLS Policies
ADD to migration file:
  - Enable RLS on all tables
  - Create policy functions for reuse
  - Add SELECT policies for org isolation
  - Add INSERT policies with checks
  - Add UPDATE policies with checks
  - Add DELETE policies (restrictive)

Task 4: Create User Profile Trigger
ADD to migration:
  - Function: handle_new_user()
  - Trigger: After INSERT on auth.users
  - Logic: Create user_profile and org if needed
  - Handle: First user is org owner

Task 5: Add Performance Indexes
ADD to migration:
  - Index on user_profiles(user_id)
  - Index on products(organization_id, sku)
  - Index on inventory(product_id, warehouse_id)
  - Index on all foreign keys
  - Partial indexes for common queries

Task 6: Create Supabase Clients
CREATE lib/supabase/client.ts:
  - Browser client with anon key
CREATE lib/supabase/server.ts:
  - Server client with cookie handling
CREATE lib/supabase/admin.ts:
  - Admin client with service role key
  - WARN: Only use server-side!

Task 7: Generate TypeScript Types
RUN commands:
  - pnpm add -D supabase
  - pnpm supabase gen types typescript --local > types/database.types.ts
  - OR for cloud: --project-id your-id
VERIFY: Types match schema

Task 8: Create Seed Data Script
CREATE supabase/seed.sql:
  - Test organization
  - Test users (owner, admin, member)
  - Sample products (100-200)
  - Sample warehouses (3-5)
  - Sample inventory data
  - Use realistic data

Task 9: Test RLS Policies
WRITE SQL tests:
  - User can't see other org's data
  - User can't insert into other org
  - User can't update other org's data
  - Service role bypasses RLS
RUN: In Supabase SQL editor

Task 10: Create Helper Functions
ADD database functions:
  - get_user_organization_id()
  - is_org_member(user_id, org_id)
  - is_org_admin(user_id, org_id)
USE: In RLS policies for DRY

Task 11: Document Schema
CREATE docs/database-schema.md:
  - Table descriptions
  - Relationship diagram
  - RLS policy explanations
  - Common query patterns

Task 12: Verify Integration
TEST from Next.js:
  - Can connect to Supabase
  - Can query with types
  - RLS works as expected
  - Errors handled gracefully
```

### Pseudocode
```sql
-- Task 2: Initial Schema Migration
-- supabase/migrations/001_initial_schema.sql

-- Enable UUID extension (pgcrypto for gen_random_uuid)
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Organizations table (multi-tenant root)
CREATE TABLE IF NOT EXISTS organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  subscription_tier TEXT DEFAULT 'starter' 
    CHECK (subscription_tier IN ('starter', 'professional', 'enterprise')),
  subscription_status TEXT DEFAULT 'active'
    CHECK (subscription_status IN ('active', 'trialing', 'past_due', 'canceled')),
  settings JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- User profiles (extends auth.users)
CREATE TABLE IF NOT EXISTS user_profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE NOT NULL,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  full_name TEXT,
  role TEXT DEFAULT 'member' 
    CHECK (role IN ('owner', 'admin', 'member')),
  permissions JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Products catalog
CREATE TABLE IF NOT EXISTS products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  sku TEXT NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  category TEXT,
  base_price DECIMAL(12,2) DEFAULT 0 CHECK (base_price >= 0),
  cost DECIMAL(12,2) DEFAULT 0 CHECK (cost >= 0),
  weight DECIMAL(10,3),
  dimensions JSONB DEFAULT '{}',
  image_url TEXT,
  active BOOLEAN DEFAULT true,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT unique_sku_per_org UNIQUE(organization_id, sku)
);

-- Warehouse locations
CREATE TABLE IF NOT EXISTS warehouses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  code TEXT NOT NULL,
  address JSONB DEFAULT '{}',
  contact JSONB DEFAULT '{}',
  is_default BOOLEAN DEFAULT false,
  active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT unique_warehouse_code UNIQUE(organization_id, code)
);

-- Inventory levels
CREATE TABLE IF NOT EXISTS inventory (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  product_id UUID REFERENCES products(id) ON DELETE CASCADE NOT NULL,
  warehouse_id UUID REFERENCES warehouses(id) ON DELETE CASCADE NOT NULL,
  quantity INTEGER DEFAULT 0 CHECK (quantity >= 0),
  reserved_quantity INTEGER DEFAULT 0 CHECK (reserved_quantity >= 0),
  reorder_point INTEGER,
  reorder_quantity INTEGER,
  last_counted_at TIMESTAMPTZ,
  last_counted_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT unique_product_warehouse UNIQUE(product_id, warehouse_id),
  CONSTRAINT reserved_not_greater_than_quantity CHECK (reserved_quantity <= quantity)
);

-- Task 3: RLS Policies
-- Enable RLS
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE warehouses ENABLE ROW LEVEL SECURITY;
ALTER TABLE inventory ENABLE ROW LEVEL SECURITY;

-- Helper function to get user's organization
CREATE OR REPLACE FUNCTION get_user_organization_id(user_uuid UUID)
RETURNS UUID AS $$
  SELECT organization_id FROM user_profiles WHERE user_id = user_uuid;
$$ LANGUAGE SQL SECURITY DEFINER;

-- Organizations policies
CREATE POLICY "Users can view their organization"
  ON organizations FOR SELECT
  USING (id = get_user_organization_id(auth.uid()));

CREATE POLICY "Only owners can update organization"
  ON organizations FOR UPDATE
  USING (
    id = get_user_organization_id(auth.uid()) 
    AND EXISTS (
      SELECT 1 FROM user_profiles 
      WHERE user_id = auth.uid() 
      AND organization_id = id 
      AND role = 'owner'
    )
  );

-- User profiles policies  
CREATE POLICY "Users can view profiles in their org"
  ON user_profiles FOR SELECT
  USING (organization_id = get_user_organization_id(auth.uid()));

-- Products policies
CREATE POLICY "Users can view products in their org"
  ON products FOR SELECT
  USING (organization_id = get_user_organization_id(auth.uid()));

CREATE POLICY "Users can manage products in their org"
  ON products FOR ALL
  USING (organization_id = get_user_organization_id(auth.uid()));

-- Continue similar patterns for warehouses and inventory...

-- Task 4: User creation trigger
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  org_id UUID;
  org_name TEXT;
BEGIN
  -- Extract organization name from metadata
  org_name := COALESCE(
    NEW.raw_user_meta_data->>'organization_name',
    'Personal Organization'
  );

  -- Try to create new organization
  INSERT INTO organizations (name, slug)
  VALUES (
    org_name,
    LOWER(REGEXP_REPLACE(org_name, '[^a-zA-Z0-9]+', '-', 'g'))
  )
  ON CONFLICT (slug) DO NOTHING
  RETURNING id INTO org_id;

  -- If conflict, find existing org (for invites later)
  IF org_id IS NULL THEN
    SELECT id INTO org_id FROM organizations
    WHERE slug = LOWER(REGEXP_REPLACE(org_name, '[^a-zA-Z0-9]+', '-', 'g'));
  END IF;

  -- Create user profile
  INSERT INTO user_profiles (
    user_id, 
    organization_id, 
    full_name, 
    role
  ) VALUES (
    NEW.id,
    org_id,
    COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email),
    CASE 
      WHEN NOT EXISTS (
        SELECT 1 FROM user_profiles WHERE organization_id = org_id
      ) THEN 'owner'
      ELSE 'member'
    END
  );

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION handle_new_user();

-- Task 5: Indexes
CREATE INDEX idx_user_profiles_user_id ON user_profiles(user_id);
CREATE INDEX idx_user_profiles_org_id ON user_profiles(organization_id);
CREATE INDEX idx_products_org_sku ON products(organization_id, sku);
CREATE INDEX idx_products_org_active ON products(organization_id, active) WHERE active = true;
CREATE INDEX idx_inventory_product_warehouse ON inventory(product_id, warehouse_id);
CREATE INDEX idx_inventory_low_stock ON inventory(organization_id, warehouse_id) 
  WHERE quantity <= reorder_point;
```

### Integration Points
```yaml
DATABASE:
  - migration: Run via supabase db push or migration run
  - types: Generate after any schema change
  - client: Use generated types in all queries
  
AUTHENTICATION:
  - trigger: Creates user_profile on signup
  - RLS: Uses auth.uid() for all policies
  - roles: Owner, admin, member permissions
  
ENVIRONMENT:
  - local: Docker-based Supabase
  - staging: Separate Supabase project
  - production: Separate Supabase project
  
DEVELOPMENT:
  - seed: Run supabase db seed for test data
  - reset: supabase db reset to start fresh
```

## Validation Loop

### Level 1: Schema Validation
```bash
# Apply migration
pnpm supabase db push

# Check migration status
pnpm supabase migration list

# Validate no SQL errors
# Expected: Migration applied successfully
```

### Level 2: Type Generation
```bash
# Generate types
pnpm supabase gen types typescript --local > types/database.types.ts

# Check TypeScript
pnpm tsc --noEmit

# Expected: No type errors
```

### Level 3: RLS Testing
```sql
-- Run in Supabase SQL Editor
-- Test as different users

-- Create test users
INSERT INTO auth.users (id, email) VALUES 
  ('11111111-1111-1111-1111-111111111111', 'user1@org1.com'),
  ('22222222-2222-2222-2222-222222222222', 'user2@org2.com');

-- Create test organizations and profiles
-- (Run seed data)

-- Test isolation
SET SESSION auth.uid = '11111111-1111-1111-1111-111111111111';
SELECT * FROM products; -- Should only see org1 products

SET SESSION auth.uid = '22222222-2222-2222-2222-222222222222';
SELECT * FROM products; -- Should only see org2 products

-- Test insert protection
SET SESSION auth.uid = '11111111-1111-1111-1111-111111111111';
INSERT INTO products (organization_id, sku, name) 
VALUES ('wrong-org-id', 'TEST', 'Test'); -- Should fail
```

### Level 4: Integration Test
```typescript
// Quick test file to verify connection
// test-db.ts
import { createClient } from '@supabase/supabase-js'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)

async function testConnection() {
  const { data, error } = await supabase
    .from('organizations')
    .select('*')
    .limit(1)
  
  if (error) {
    console.error('Connection failed:', error)
  } else {
    console.log('Connection successful:', data)
  }
}

testConnection()
```

## Final Validation Checklist
- [ ] Supabase project running (local or cloud)
- [ ] All migrations applied successfully
- [ ] No SQL syntax errors in migrations
- [ ] TypeScript types generated without errors
- [ ] RLS policies block cross-org access
- [ ] User creation trigger works
- [ ] Seed data loads successfully
- [ ] Can query from Next.js app
- [ ] Service role key only used server-side
- [ ] All tables have RLS enabled
- [ ] Indexes created for common queries
- [ ] Documentation explains schema

## Anti-Patterns to Avoid
- ❌ Don't forget RLS on any table - security breach
- ❌ Don't use serial IDs - use UUIDs for security
- ❌ Don't store service role key in browser
- ❌ Don't skip ON DELETE CASCADE - orphaned data
- ❌ Don't use user_id in policies - use auth.uid()
- ❌ Don't forget composite unique constraints
- ❌ Don't skip indexes on foreign keys
- ❌ Don't use timestamp without timezone