Fix the following issues. The issues can be from different files or can overlap on same lines in one file.

- In __tests__/unit/lib/sync/sync-engine.test.ts at line 39, the mock for createClient is incorrectly set to return a resolved promise, implying it is asynchronous. Since createClient is used synchronously in the codebase, change the mock to return the mockSupabase object directly without wrapping it in a promise, ensuring the mock matches the actual function's synchronous behavior.

- In app/(dashboard)/customers/[id]/pricing/page.tsx around lines 133 to 134, the count values pendingApprovalsCount and expiringContracts might be null, which can cause UI issues. Replace the logical OR (||) with nullish coalescing (??) to safely default to 0 only when the values are null or undefined, ensuring correct handling of falsy but valid counts like 0.

- In app/(dashboard)/integrations/netsuite/callback/page.tsx around lines 94 to 103, the code updates the integration status to 'active' immediately after calling auth.exchangeCodeForTokens without verifying if the token exchange succeeded. Modify the code to check the result of the token exchange call, confirm tokens are valid or stored successfully, and only then update the integration status to 'active'. If the token exchange fails, handle the error appropriately and avoid updating the status.

- In app/(dashboard)/integrations/netsuite/callback/page.tsx around lines 116 to 128, the error details are logged directly, which may expose sensitive information. To fix this, sanitize or redact sensitive parts of the errorMessage before including it in the p_details field of the log_integration_activity RPC call. Implement a function or logic to filter out or mask sensitive data from errorMessage prior to logging.

- In app/(dashboard)/integrations/netsuite/page.tsx at line 94, there is a redirect to the current NetSuite integration page which is redundant. Remove this redirect call to avoid unnecessary page reloads or clarify its purpose if it serves a specific function beyond navigation.

- In app/(dashboard)/integrations/netsuite/page.tsx around lines 261 to 264, replace the direct window.location.href assignment with the Next.js Link component to handle navigation. This change will prevent a full page reload and improve performance by enabling client-side routing. Wrap the clickable element with the Link component pointing to `/api/integrations/netsuite/auth?integration_id=${integration.id}` and remove the onClick handler that sets window.location.href.

- In app/(dashboard)/monitoring/alerts/[alertId]/page.tsx at line 19, the createClient() function call is missing an await keyword. Since createClient() returns a promise, add the await keyword before createClient() to properly wait for the client to be created before proceeding.

- In app/(dashboard)/monitoring/alerts/[alertId]/page.tsx between lines 27 and 82, the database queries lack error handling, which can cause unhandled exceptions if a query fails. Add try-catch blocks around each supabase query to catch and handle errors gracefully. Inside the catch block, log the error and handle it appropriately, such as returning a notFound() or an error message, to ensure the app does not crash unexpectedly.

- In app/(dashboard)/monitoring/alerts/page.tsx around lines 37 to 42, the query fetching alert rules from supabase lacks error handling. Modify the code to check for errors returned by the query, handle them explicitly by logging or displaying an appropriate message, and ensure the component can respond accordingly instead of silently failing with an empty array.

- In app/(dashboard)/monitoring/alerts/page.tsx around lines 26 to 34, the Supabase query fetching the organization user does not handle potential database errors. Modify the code to check for errors returned by the Supabase query and handle them appropriately, such as logging the error or showing an error message, before deciding to redirect or proceed. This ensures that database errors are not silently ignored.

- In app/(dashboard)/monitoring/analytics/page.tsx around lines 33 to 53, the Promise.all call to AccuracyScorer methods lacks error handling, which can cause the page to crash if any call fails. Wrap the Promise.all call in a try-catch block to catch and handle errors gracefully, such as logging the error and providing fallback values or UI feedback to maintain page stability.

- In app/(dashboard)/monitoring/analytics/page.tsx around lines 13 to 31, the database query fetching the user's organization does not handle potential errors. Modify the code to capture and check for errors returned by the query, and handle them appropriately, such as redirecting to an error page or showing a message, to ensure graceful failure if the query fails.

- In app/(dashboard)/monitoring/analytics/page.tsx around lines 55 to 61, the integrations query lacks error handling, which can cause the page to break if the query fails. Add error handling by capturing the error returned from the supabase query and handle it appropriately, such as logging the error and providing fallback behavior or user feedback to prevent the page from crashing.

- In app/(dashboard)/monitoring/page.tsx around lines 12 to 31, the query fetching the user's organization lacks error handling. Add a check for errors returned by the supabase query on 'organization_users' and handle them appropriately, such as logging the error or redirecting the user, to ensure the app behaves correctly if the query fails.

- In app/(dashboard)/monitoring/page.tsx between lines 33 and 76, the Promise.all call fetching multiple data queries lacks error handling, which can cause the entire page to crash if any query fails. Wrap the Promise.all call in a try-catch block to catch any errors during the queries. In the catch block, handle the error gracefully by logging it and providing fallback data or error states to prevent the page from crashing.

- In app/actions/customer-pricing.ts between lines 135 and 158, the current code deletes all contract items before inserting new ones without transaction protection, risking data loss if insertion fails. To fix this, wrap the delete and insert operations inside a single database transaction or use a Supabase RPC function to perform the update atomically. This ensures that either both operations succeed or none are applied, preventing partial updates and data loss.

- In app/actions/monitoring.ts around lines 150 to 155, the deleteAlertRule function deletes an alert rule without verifying if it belongs to the user's organization. Modify the delete query to include a condition that checks the alert rule's organization ID matches the user's organization ID, ensuring only rules owned by the user's organization can be deleted.

- In app/actions/shopify-integration.ts between lines 63 and 101, the current code manually rolls back the integration insert if the config insert fails, which is not fully reliable. To fix this, refactor the code to wrap the integration and config inserts inside a single database transaction using Supabase's transaction support or a stored procedure (RPC). This ensures atomicity so that either both inserts succeed or both fail together, eliminating the risk of partial data insertion.

- In app/actions/sync-engine.ts around lines 233 to 247, the SyncJobManager instance is created but lacks a cleanup method to release resources. Review the SyncJobManager class to identify any held resources like timers or connections, then implement a cleanup method (e.g., stop or close) to properly release them. Finally, call this cleanup method in the finally block after job processing to prevent resource leaks.

- In app/actions/sync-engine.ts around lines 303 to 313, the upsert operation always sets created_by to the current user, overwriting the original creator on updates. Modify the code to set created_by only when inserting a new record, not on updates. This can be done by separating the insert and update data or using conditional logic to exclude created_by from the update payload, ensuring the original creator is preserved.

- In app/actions/sync-engine.ts around lines 745 to 751, the query incorrectly filters active jobs by organization_id directly on the sync_jobs table. Instead, update the query to filter organization_id through the integration relationship, likely by joining or using a related table or foreign key path to access organization_id from the integration associated with each sync_job.

- In app/api/cron/accuracy/route.ts around lines 53 to 63, the current code processes all organizations sequentially without concurrency control, which can cause resource exhaustion if there are many organizations. Refactor the loop to process organizations in batches with a fixed batch size (e.g., 5). Slice the organizations array into batches and use Promise.all to process each batch concurrently, awaiting completion before moving to the next batch to limit simultaneous operations and prevent system overload.

- In app/api/cron/accuracy/route.ts between lines 90 and 117, the asynchronous accuracy check is started without awaiting its completion, which can cause the function to exit before the process finishes. To fix this, collect all accuracyChecker.runCheck promises in an array and use Promise.allSettled to wait for all to complete before sending the HTTP response. Alternatively, implement a job queue to handle these checks outside the request lifecycle, ensuring all async operations complete properly.

- In app/api/cron/accuracy/route.ts between lines 218 and 239, the POST endpoint currently lacks authentication and does not utilize the organizationId parameter correctly. To fix this, implement proper authentication logic at the start of the function to verify the request's credentials. Then, ensure the organizationId from the request body is passed appropriately to the AccuracyChecker's runCheck method or used in the logic to scope the check to the specified organization. This will secure the endpoint and correctly apply the organization context.

- In app/api/cron/health-check/route.ts around lines 29 to 34, the error message reveals whether CRON_SECRET is configured, which can disclose sensitive information. Change the error log to a generic message that does not indicate if CRON_SECRET is missing or the authorization is invalid. This prevents leaking configuration details while still indicating an authentication failure.

- In app/api/cron/health-check/route.ts around lines 111 to 118, the SyncEngine instance is only shut down if no error occurs, risking resource leaks. Refactor the code to ensure that syncEngine.shutdown() is called regardless of success or failure by moving the shutdown call into a finally block after the try-catch. This guarantees cleanup on all code paths.

- In app/api/cron/sync/[frequency]/route.ts around lines 107 to 117, the current check for active hours does not handle cases where the active period spans midnight (e.g., start at 22:00 and end at 02:00). To fix this, update the condition to detect if endHour is less than or equal to startHour, and if so, check if the currentHour is either greater than or equal to startHour or less than endHour; otherwise, keep the existing check. This will correctly allow schedules that span midnight to run during their active hours.

- In app/api/integrations/[id]/sync/route.ts around lines 65 to 72, the current error logging includes raw user emails, which risks exposing sensitive personal data. To fix this, remove the userEmail field from the log or replace it with a pseudonymized version such as a masked email or a one-way hash (e.g., SHA-256). Ensure that only necessary user identifiers like userId are logged, and confirm that any logs containing PII follow encryption, access control, and retention policies.

- In app/api/integrations/netsuite/auth/route.ts around lines 19 to 20, the integration_id
query parameter is retrieved but not validated. Add a check to validate that integration_id
is a valid UUID format before proceeding. Use a UUID validation method or regex to verify
the format and handle invalid cases appropriately, such as returning an error response.

- In app/api/integrations/netsuite/auth/route.ts around lines 142 to 146, avoid initializing access_token and refresh_token with empty strings as placeholders to prevent accidental usage before proper assignment. Instead, set these fields to null or omit them entirely when creating the object, ensuring tokens are only present when valid values exist.

- In app/api/monitoring/accuracy/check/route.ts between lines 53 and 100, the ReadableStream setup for SSE lacks a cancel handler to remove event listeners if the client disconnects early. Add a cancel method to the stream's underlying source that removes the progress, complete, and error event listeners from the checker to prevent memory leaks when the stream is cancelled.

- In app/api/monitoring/alerts/[id]/acknowledge/route.ts between lines 59 and 86, the alert status update and audit log insert are performed separately without transaction handling, risking data inconsistency if the audit log insert fails after the alert update. To fix this, wrap both operations in a single database transaction so that if the audit log insert fails, the alert update is rolled back. You can achieve this by creating a stored procedure or RPC that performs both actions atomically, or at minimum, handle errors from the audit log insert and rollback the alert update if necessary.

- In app/api/monitoring/alerts/[id]/acknowledge/route.ts at line 94, replace orgUser.user_id with user.id to maintain consistency in the response object. Ensure that the user object is correctly referenced and that user.id is used instead of orgUser.user_id.

- In app/api/monitoring/alerts/[id]/acknowledge/route.ts at line 65, replace the use of orgUser.user_id with user.id for the acknowledged_by field to maintain consistency and clarity by directly using the authenticated user's ID.

- In app/api/monitoring/alerts/route.ts around lines 33 to 34, the pagination parameters 'limit' and 'offset' are parsed without validation, which can lead to invalid or malicious values causing issues. Add validation to ensure 'limit' and 'offset' are valid non-negative integers, set reasonable maximum values for 'limit' to prevent excessively large requests, and fallback to default values if validation fails.

- In app/api/monitoring/alerts/route.ts around lines 98 to 101, the current type assertions for alert.status and alert.severity may cause runtime errors if unexpected values are present. To fix this, add validation checks to ensure alert.status and alert.severity exist as keys in summary.byStatus and summary.bySeverity before incrementing. Use conditional statements to safely handle or skip invalid values to prevent runtime exceptions.

- In app/api/monitoring/status/route.ts around lines 55 to 68, the use of .single() on the accuracy_checks query assumes exactly one row exists, but it can throw an error if no rows are found. Modify the code to handle the case when no accuracy checks exist by checking if data is null or undefined after the query and handle that scenario gracefully without throwing an error.

- In app/api/webhooks/[platform]/route.ts around lines 276 to 277, remove the unnecessary type casting of `origin` to `any` in the includes check against `ALLOWED_WEBHOOK_ORIGINS`. Instead, ensure that the type of `origin` matches the type expected by `ALLOWED_WEBHOOK_ORIGINS` or adjust the type definition of `ALLOWED_WEBHOOK_ORIGINS` to be compatible with `origin`. This will maintain type safety without suppressing TypeScript errors.

- In app/api/webhooks/[platform]/route.ts around lines 38 to 49, the shop domain header value is used directly in the database query without validation. Add validation to check that the shopifyShop value is a valid, non-empty string and matches expected patterns (e.g., a valid domain format) before using it in the query. If validation fails, handle it gracefully by returning null or an appropriate error response.

- In app/api/webhooks/netsuite/route.ts at lines 195 and 205, the createClient() function is called without awaiting its asynchronous result. Update both calls to await createClient() to ensure the client is fully initialized before use, preventing potential runtime errors due to unfulfilled promises.

- In app/api/webhooks/netsuite/route.ts at line 344, the property name `endpoint_url` does not match the database column name `url` in the webhook_endpoints table. Rename `endpoint_url` to `url` to align with the database schema and ensure correct data mapping.

- In app/api/webhooks/shopify/route.ts around lines 64 to 66, the current rate limit cleanup runs randomly on 1% of requests, which may be insufficient under high load. Replace this random trigger with a deterministic approach, such as scheduling cleanup at fixed intervals or after a certain number of requests, to ensure consistent and predictable rate limit maintenance.

- In components/features/integrations/integration-item.tsx around lines 108 to 115, the usage of the format function on lastSyncDate may throw an error if the date is invalid. To fix this, add error handling around the format call by either validating lastSyncDate before formatting or wrapping the format call in a try-catch block. If an error occurs, display a fallback message or omit the date display to prevent the component from crashing.

- In components/features/integrations/integration-item.tsx around lines 129 to 137, the sync button lacks visual feedback during the loading state. Update the button to show a loading indicator or spinner when isLoading is true, such as adding a spinning animation to the icon or disabling the button with a loading label, so users clearly see that the sync operation is in progress.

- In components/features/integrations/integration-item.tsx around lines 32 to 38, the IntegrationItemProps interface is loosely typed and may cause runtime errors. Refine the interface by specifying exact types for each property, ensuring that IntegrationFull is well-defined and that the function signatures for onSync, onToggleStatus, and onDelete use precise parameter and return types. This will improve type safety and prevent potential runtime issues.

- In components/features/integrations/integration-item.tsx around lines 64 to 71, improve robustness by validating integration.last_sync_at before creating a Date object to handle malformed or invalid date strings safely. Also, add error handling or checks when filtering sync_jobs to ensure the data exists and is in the expected format, preventing runtime errors from malformed or missing job entries.

- In components/features/integrations/netsuite/netsuite-field-mappings.tsx around lines 130 to 145, the conversion from the mappings prop to the fieldMappings state uses unsafe type assertions and lacks validation. To fix this, add runtime checks to ensure that fields is an object with string keys and string values before pushing to mappingArray. Replace the type assertions with proper type guards or validation logic to confirm the structure matches ExtendedFieldMapping requirements, preventing potential runtime errors.

- In components/features/integrations/netsuite/netsuite-field-mappings.tsx around lines 214 to 222, the code uses customSourceField and customTargetField without validating their values, risking invalid data being saved. Add validation checks to ensure customSourceField and customTargetField are non-empty and meet any required format or constraints before assigning them to mappingsByEntity. Only proceed with saving the mapping if the custom fields pass these validations.

- In components/features/integrations/netsuite/netsuite-sync-settings.tsx around lines 61 to 62, the code calls .join() on config.inventory_locations and config.price_levels without verifying they are arrays, which can cause runtime errors. Add defensive checks to confirm these properties are arrays before calling .join(), and provide a fallback (like an empty string) if they are not arrays or are undefined.

- In components/features/integrations/netsuite/netsuite-sync-settings.tsx around lines 42 to 45, the config prop is currently typed as any, which disables type checking. Define a proper TypeScript interface that accurately represents the expected structure of the config object and replace the any type with this interface to enable type safety and better code clarity.

- In components/features/integrations/netsuite/netsuite-sync-status.tsx at line 226, replace the hardcoded array ['products', 'inventory', 'pricing', 'customers', 'orders'] with a derived array from the keys of the ENTITY_ICONS constant to ensure consistency and avoid duplication. Use Object.keys or a similar method to extract the entity types dynamically from ENTITY_ICONS.

- In components/features/monitoring/accuracy-analytics-dashboard.tsx around lines 70 to 74, the convertReportToCSV function currently returns a placeholder string instead of actual CSV data, causing CSV export to fail. Replace the placeholder implementation with a proper CSV conversion that extracts headers and rows from the report data, formats each cell with quotes, and joins them with commas and newlines. You can either implement this manually as shown in the example or use a CSV library to generate the CSV string correctly.

- In components/features/monitoring/accuracy-chart.tsx around lines 17 to 20, the data prop is typed as any[], which reduces type safety and editor support. Define a specific interface describing the shape of each data item used in the accuracy chart, then update the data prop type to use this interface array instead of any[]. This will improve type safety and IntelliSense.

- In components/features/monitoring/accuracy-comparison-chart.tsx around lines 58 to 65, the default accuracy is set to 100% when no metrics exist, which can mislead users into thinking accuracy is perfect despite missing data. Change the default accuracy to a more neutral value such as null or undefined to indicate missing data, or modify the logic to exclude integrations without metrics from the chart display entirely.

- In components/features/monitoring/accuracy-comparison-chart.tsx at line 97, the useEffect dependency array includes the supabase client, which is recreated on every render causing unnecessary re-fetches. To fix this, remove supabase from the dependency array or ensure the supabase client is memoized so it remains stable across renders, preventing redundant effect executions.

- In components/features/monitoring/accuracy-dashboard.tsx at lines 20 and 237, verify the exact exported component name from the accuracy-chart file by searching for its export statement. If the component is actually named AccuracyTrendChart or another variant, update the import statement to match the correct export name. This ensures the imported component name aligns with the actual exported component to prevent runtime errors.

- In components/features/monitoring/accuracy-dashboard.tsx around lines 255 to 260 and 275 to 280, the onResolve and onAcknowledge handlers currently only log to the console as placeholders. Replace these console.log statements with calls to the appropriate server action functions that handle resolving and acknowledging discrepancies. Ensure these handlers await the server action calls and then trigger the refresh function to update the UI accordingly.

- In components/features/monitoring/accuracy-heatmap.tsx around lines 100 to 117, improve accessibility by adding appropriate ARIA attributes such as role="button" or aria-label to the heatmap cells for better screen reader support. Also, handle null or undefined accuracy values explicitly by checking if accuracy is null before using it, and provide a fallback or indication for missing data instead of defaulting to 100. Update the title and displayed text accordingly to reflect accurate or missing data.

- In components/features/monitoring/accuracy-heatmap.tsx around lines 12 to 52, optimize the data processing by memoizing the daysOfWeek array outside the useMemo hook to avoid recreating it on every render. Fix the accuracy calculation by setting a more appropriate default accuracy value when count is zero, such as null or 0 instead of 100, to avoid misleading results. Refactor the aggregation logic to improve clarity and efficiency, ensuring the grouped data structure is initialized once and reused properly.

- In components/features/monitoring/accuracy-trend-chart.tsx around lines 82 to 83, the calculation of yAxisDomain does not properly handle edge cases where minAccuracy minus 5 could produce a negative or otherwise invalid lower bound. Add bounds checking to ensure the lower bound is never less than 0 and does not exceed the maximum accuracy value. Adjust the calculation to clamp the lower bound within valid limits before setting yAxisDomain.

- In components/features/monitoring/accuracy-trend-chart.tsx around lines 55 to 80, the CustomTooltip component uses 'any' for props which reduces type safety and lacks accessibility attributes. Replace 'any' with a proper type interface for the tooltip props to ensure type safety. Add appropriate ARIA attributes and roles to the tooltip container to improve accessibility, such as role="tooltip" and aria-label or aria-describedby as needed.

- In components/features/monitoring/accuracy-trend-chart.tsx around lines 32 to 45, the code assumes all data points are valid without validation, which can cause runtime errors if data is malformed. Add validation checks inside the useMemo callback to ensure each data point has the expected properties with correct types before processing. If invalid data is detected, handle it gracefully by either filtering out those points or returning an empty array, and consider logging a warning for debugging.

- In components/features/monitoring/alert-config-dialog.tsx at line 370, remove the unnecessary and unsafe type assertion `as any` from the expression `channel.value as any`. Instead, ensure that the type of `channel.value` matches the expected type for the `includes` method on `field.value` by properly typing `channel.value` or adjusting the types so no casting is needed.

- In components/features/monitoring/alert-config-dialog.tsx at line 58, the rule prop is currently typed as any, which bypasses TypeScript's type safety. Define a proper interface describing the expected structure of the rule object and replace the any type with this interface to ensure type safety and improve maintainability.

- In components/features/monitoring/alert-config-dialog.tsx around lines 76 to 99, the defaultValues object does not properly handle updates when the rule prop changes, and some field mappings are inconsistent with the form schema. To fix this, ensure that the form resets its values whenever the rule prop changes by using a useEffect hook that calls the form reset method with the updated default values. Also, verify and correct all field mappings between the rule object properties and the form fields to maintain consistency and prevent stale or incorrect data in the form state.

- In components/features/monitoring/alert-config-dialog.tsx around lines 101 to 127, the handleSubmit function only shows a toast on submission failure without handling specific error scenarios or recovery. Enhance error handling by checking for different error types or codes in the result.error, and implement appropriate recovery actions such as retry options, form validation feedback, or detailed error messages. Ensure the UI reflects the error state clearly and allows the user to correct or retry the submission.

- In components/features/monitoring/alert-detail-view.tsx around lines 26 to 30, the AlertDetailViewProps interface uses 'any' types for alert, notifications, and discrepancies, which undermines TypeScript's type safety. Replace 'any' with specific, well-defined types or interfaces that accurately describe the shape and properties of alert, notifications, and discrepancies to improve type safety and code clarity.

- In components/features/monitoring/alert-detail-view.tsx at line 189, remove the unsafe 'as any' type assertion on the Badge component's variant prop. Instead, update the type definitions so that the variant prop accepts all possible return values from the getSeverityColor function, ensuring proper type safety without bypassing TypeScript checks.

- In components/features/monitoring/alert-history.tsx around lines 87 to 89, the Badge component's variant prop is cast using 'as any', which bypasses TypeScript's type safety. To fix this, update the getStatusColor function to explicitly return the correct variant string union type matching Badge's expected variants, such as "default" | "destructive" | "secondary" | "outline". Then remove the 'as any' cast from the Badge variant prop to ensure proper typing.

- In components/features/monitoring/alert-history.tsx around lines 18 to 21, the alerts prop is typed as any[], which disables TypeScript's type checking. Define a proper interface describing the shape of an alert object with all expected properties, then replace any[] with this new interface array type to ensure type safety and better code clarity.

- In components/features/monitoring/alert-rules-list.tsx around lines 73 to 91, the delete action lacks a confirmation step. Add a confirmation dialog before proceeding with the deletion to ensure users explicitly confirm the destructive action. Implement a modal or browser confirm dialog that prompts the user to confirm or cancel the deletion, and only call deleteAlertRule if the user confirms.

- In components/features/monitoring/alert-rules-list.tsx around lines 35 to 36, replace the use of `any[]` and `string` types with properly defined TypeScript interfaces that describe the shape of the `rules` array elements and the `organizationId`. Define an interface for the rule objects with all expected properties and use it instead of `any[]` to improve type safety and prevent runtime errors.

- In components/features/monitoring/alert-rules-list.tsx around lines 44 to 71, the handleToggleActive function rebuilds the entire rule object manually and lacks optimistic UI updates, which can cause errors and poor user experience. Refactor the function to update only the changed isActive property when calling upsertAlertRule, and implement optimistic updates by immediately updating the UI state before awaiting the API response. Also, improve error handling by reverting the UI state if the update fails and showing appropriate feedback to the user.

- In components/features/monitoring/discrepancy-table.tsx around lines 143 to 146, the "View Details" DropdownMenuItem lacks an onClick handler, making it non-functional. To fix this, either add an appropriate onClick handler that triggers the intended "View Details" functionality or remove the DropdownMenuItem entirely if the feature is not ready or needed.

- In components/features/monitoring/discrepancy-table.tsx around lines 24 to 27, the discrepancies prop is typed as any[], which reduces type safety. Define a proper TypeScript interface describing the structure of a discrepancy object with all expected properties, then replace any[] with an array of that interface type to improve type safety and code clarity.

- In components/features/pricing/approval-queue.tsx around lines 4 and also 224 to 226, the useRouter hook is imported but the router variable is not initialized from it. Fix this by calling const router = useRouter() after the other hooks in the component, so that the router variable is properly defined and can be used in the View Details button click handler.

- In components/features/pricing/contract-details-section.tsx around lines 289 to 293 and also near line 310, the onChange handler uses parseInt directly which can produce NaN for invalid inputs. Update the onChange function to first parse the input, then check if the result is a valid number before calling field.onChange. If the parsed value is NaN, handle it appropriately (e.g., set to undefined or an empty string) to prevent invalid values from propagating.

- In components/features/pricing/contract-items-section.tsx around lines 159 to 174, add validation to the max quantity input to ensure that when a value is provided, it is not less than the min quantity. Implement this by checking the input value against item.min_quantity before calling onUpdateItem, and prevent updates or show an error if the max quantity is less than the min quantity.

- In components/features/pricing/contract-list.tsx around lines 76 to 79, the catch block currently displays the raw error message to users via toast.error, which may expose sensitive internal details. Modify the toast.error call to show a generic, user-friendly error message instead, such as "Failed to cancel contract. Please try again later." Keep the detailed error logging in console.error for debugging purposes.

- In components/features/pricing/contract-list.tsx around lines 95 to 98, the error handling for the renew contract operation currently exposes internal error details in the toast error message. Modify the toast.error call to display a generic error message without revealing the error.message, similar to the cancel operation, to maintain consistent and secure error handling.

- In components/features/pricing/price-export-button.tsx at line 5, the toast import is from 'sonner', which is inconsistent with the rest of the codebase that uses '@/components/ui/use-toast'. Replace the import statement to import the toast function from '@/components/ui/use-toast' instead, and update all toast calls in this file to use the imported toast from that module to maintain consistent styling and behavior.

- In components/features/pricing/price-export-button.tsx around lines 34 to 46, the blob URL created with URL.createObjectURL is not revoked, which can cause memory leaks. After triggering the link click and removing the link element from the DOM, call URL.revokeObjectURL(url) to properly release the blob URL and prevent memory leaks in long-running sessions.

- In components/features/pricing/price-export-button.tsx at line 40, the filename sanitization only replaces spaces with underscores, which can still allow problematic characters in filenames. Improve this by replacing or removing all characters that are not alphanumeric, underscores, or hyphens to ensure the filename is safe for downloads. Use a regex to sanitize the customerName string more comprehensively before constructing the filename.

- In components/features/pricing/price-history-timeline.tsx around lines 279 to 306, the percentage change calculation does not handle cases where old_price is very small but not zero, which can cause misleading or extreme percentage values. Update the calculation to include a threshold check for old_price being sufficiently large before computing the percentage change; if old_price is below this threshold, handle the case separately to avoid misleading results, such as by displaying no change or a specific message.

- In components/features/sync/manual-sync-trigger.tsx around lines 79 to 112, improve error handling by ensuring all possible errors are caught and displayed clearly in the toast notification. Add validation feedback before submission to check required fields and invalid inputs, preventing submission if validation fails. Also, consider disabling the submit button while submitting to avoid duplicate requests and provide visual feedback on form validation errors.

- In hooks/use-accuracy-monitor.ts around lines 11 to 13, the arrays initialChecks, initialAlerts, and initialDiscrepancies are typed as any[], which reduces type safety. Define proper TypeScript interfaces for AccuracyCheck, Alert, and Discrepancy with relevant fields, then update the types of these arrays to use the newly defined interfaces instead of any[]. This will improve type safety and code clarity.

- In hooks/use-accuracy-monitor.ts around lines 42 to 49, the use of single() on the Supabase query can throw an error if no matching record is found. Replace single() with maybeSingle() to safely handle cases where no data exists without throwing, or add error handling logic to catch and manage the exception from single().

- In hooks/use-accuracy-monitor.ts around lines 31 to 95, the refresh function does not handle errors from the asynchronous calls, risking unhandled promise rejections. Add a catch block inside the try statement to catch any errors thrown during the Promise.all call, and handle them appropriately, such as logging the error or setting an error state. This will ensure that errors are managed gracefully without breaking the app flow.

- In hooks/use-customer-pricing.ts at lines 36, 54, 69, and 87, the payload parameters are typed as 'any', which reduces type safety. Replace 'any' with specific TypeScript types that accurately represent the structure of the Postgres change payloads being handled. Define or import appropriate interfaces or types for these payloads and apply them to all these parameters to improve type safety and code clarity.

- In hooks/use-customer-pricing.ts at line 182, replace the direct assignment to window.location.href with Next.js router navigation to avoid a full page reload. Import the useRouter hook from 'next/router', get the router instance, and use router.push('/pricing/approvals') for client-side navigation instead of window.location.href.

- In hooks/use-customer-pricing.ts around lines 24 to 95, the async function setupRealtimeSubscription does not handle errors during the subscription setup, risking silent failures. Add try-catch blocks around the subscription creation and subscription call to catch and log any errors. Ensure that any caught errors are properly logged or handled to prevent silent failures and improve observability.

- In hooks/use-products-query.ts at line 36, the code accesses product.product_pricing[0]?.base_price but does not handle the case where product_pricing could be null instead of an array. To fix this, add a null check to ensure product_pricing is an array before accessing its first element, and default to 0 if it is null or empty. This prevents runtime errors when product_pricing is null due to Supabase join behavior.

- In lib/email/price-approval-notification.ts around lines 311 to 312, the actionUrl is used in the plain text email without validation. Add a URL validation step before including actionUrl in the plain text email to ensure it is a legitimate URL, similar to the validation done for the HTML version. This will prevent invalid or malicious URLs from being sent.

- In lib/email/price-approval-notification.ts at line 274, the actionUrl is directly embedded into the HTML anchor tag without validation or sanitization, posing a security risk. To fix this, validate that actionUrl is a well-formed and safe URL before use, and sanitize it to escape any potentially harmful characters. Implement URL validation logic and ensure the final inserted URL cannot introduce XSS or injection vulnerabilities.

- In lib/integrations/auth-manager.ts around lines 37 to 42, the NetSuite OAuth configuration has empty authorizationUrl and tokenUrl fields, causing errors in OAuth 2.0 flow methods. To fix this, either implement separate OAuth 1.0a handling for NetSuite, update the configuration to use NetSuite's OAuth 2.0 endpoints if supported, or modify the OAuth methods to throw clear, descriptive errors when NetSuite is used with unsupported OAuth 2.0 flows.

- In lib/integrations/auth-manager.ts between lines 449 and 463, remove the duplicate creation of the Supabase client inside the catch block. Instead of calling createClient() again at line 451, reuse the existing Supabase client instance that was created earlier around line 362 to avoid unnecessary client instantiation.

- In lib/integrations/auth-manager.ts around lines 326 to 346, the code assumes the token response contains specific fields without validating the response structure, which can cause runtime errors if the OAuth provider returns an unexpected format. Add validation checks to ensure required fields like access_token and expires_in exist and have the expected types before using them. If validation fails, handle the error gracefully by throwing an informative error or returning a failure response to prevent runtime exceptions.

- In lib/integrations/auth-manager.ts around lines 85 to 92, the code assigns credentials.expires_at to accessTokenExpiresAt without validating if it is a valid ISO date string. To fix this, add a check to confirm that expires_at is a valid ISO date string before assigning it. You can do this by attempting to parse the date and verifying it is valid, only then assign accessTokenExpiresAt; otherwise, handle the invalid format appropriately.

- In lib/integrations/encryption.ts around lines 324 to 334, the current timing-safe comparison uses charCodeAt for character comparison, which is less secure and can cause issues with Unicode strings. Replace this with a byte-level comparison by converting both signatures to Buffer objects and then comparing their bytes in a timing-safe manner to improve security and correctness.

- In lib/integrations/encryption.ts at line 136, avoid using a hardcoded default salt value in the hash function as it weakens security. Remove the default salt parameter and require the caller to provide an explicit salt, or alternatively, implement logic to generate a unique random salt within the function if none is provided. This ensures each hash uses a strong, unique salt to prevent rainbow table attacks.

- In lib/integrations/encryption.ts at line 203, replace the Node.js-specific Buffer.from(data, 'base64') call with a Web Crypto API compatible method to decode base64 data. Use the global atob function or a similar Web Crypto API approach to convert the base64 string to a Uint8Array or ArrayBuffer, ensuring consistency and compatibility across environments.

- In lib/integrations/encryption.ts lines 9 to 20, the timingSafeEqual function returns early if the input arrays have different lengths, which creates a timing side-channel vulnerability. To fix this, remove the early return and instead perform a comparison that always takes the same amount of time regardless of input lengths, such as comparing up to the maximum length and incorporating length differences into the result. Alternatively, replace this function with a call to a built-in timing-safe comparison method from the Web Crypto API if available, or enforce that callers only pass equal-length inputs.

- In lib/integrations/netsuite/api-client.ts from lines 124 to 202, the rate limiter acquire and release logic is duplicated in getRecord and createRecord methods, and the release can happen twice in getRecord. Refactor by extracting a private helper method that takes a weight and an async operation, acquires the rate limiter before running the operation, and releases it in a finally block to ensure single release. Then update getRecord and createRecord to call this helper with their logic inside the operation callback, removing the explicit acquire/release code from those methods.

- In lib/integrations/netsuite/auth.ts at lines 195 and 205, the createClient() function calls are missing the await keyword. Since createClient() is asynchronous, prefix these calls with await to properly handle the returned promises. Make sure to mark the containing function as async if it is not already.

- In lib/integrations/netsuite/auth.ts at line 389, the createClient() call is asynchronous but is not awaited, which can cause issues with uninitialized clients. Modify the code to await the createClient() call by adding the await keyword before it. Also, apply the same fix at line 415 in the verifyOAuthState() method by awaiting the createClient() call there as well.

- In lib/integrations/netsuite/auth.ts at line 337, the createClient() function is asynchronous and should be awaited. Modify the code to await the createClient() call by adding the 'await' keyword before it, and ensure the containing function is declared as async if it is not already.

- In lib/integrations/netsuite/connector.ts at line 32, the NetSuite configuration is assigned by directly casting config.settings without validation. To fix this, add a validation step before the assignment to ensure config.settings conforms to the expected NetSuiteIntegrationConfig structure. Use type guards or a validation library to check required fields and types, and handle invalid configurations by throwing an error or providing a fallback.

- In lib/integrations/netsuite/connector.ts lines 475 to 512, the updatePricing method currently performs a product lookup and pricing update inside a loop, causing N+1 query inefficiency. To fix this, first batch query all products by their SKUs in a single query before the loop, mapping SKUs to product IDs. Then, iterate over the pricing array and perform upserts without additional product lookups. This reduces database calls and improves performance for large datasets.

- In lib/integrations/netsuite/connector.ts around lines 231 to 235, the inventory query using this.client.executeSuiteQL(query) lacks pagination, which can cause problems with large datasets. Modify the query execution to include pagination by splitting the query results into manageable chunks, using SuiteQL's pagination features or by adjusting the query with LIMIT and OFFSET clauses. Implement a loop or recursive call to fetch all pages of results until no more data remains, then aggregate these results before returning.

- In lib/integrations/netsuite/queries.ts at line 27, the current approach removes SQL keywords from input values, which can corrupt legitimate data containing those words. Instead of stripping these keywords, refactor the code to use parameterized queries or properly escape input values to prevent SQL injection while preserving data integrity. If NetSuite supports parameterized queries, leverage that feature to safely handle user inputs without manual keyword removal.

- In lib/integrations/netsuite/transformers.ts around lines 417 to 441, the transformWeight method lacks validation for negative weight values, which are likely invalid. Add a check at the start of the method to return undefined or handle the case if the weight is less than or equal to zero, ensuring only positive weight values are processed and converted.

- In lib/integrations/netsuite/transformers.ts around lines 135 to 178, the transformProduct method lacks validation for essential fields like sku and name before processing, which may cause invalid data issues. Add checks at the start of the method to verify that item.sku and item.name are present and valid; if either is missing or empty, throw an error indicating the missing required field to prevent further processing of incomplete data.

- In lib/integrations/shopify/api-client.ts around lines 33 to 41, the constructor currently assigns configuration parameters without validation, which may cause runtime errors. Add validation checks to ensure the `shop` parameter matches the expected Shopify domain pattern, the `apiVersion` matches the YYYY-MM format, and the `accessToken` is not empty. If any validation fails, throw an appropriate error to prevent incorrect configuration usage.

- In lib/integrations/shopify/bulk-operations.ts lines 267 to 302, the createBulkInventoryAdjust method directly interpolates user input into the GraphQL mutation string, risking GraphQL injection. To fix this, refactor the method to use GraphQL variables for all user-supplied values instead of string interpolation. Construct the mutation with variable placeholders and pass the actual values separately as variables to safely parameterize the query.

- In lib/integrations/shopify/transformers.ts around lines 20 to 21 and also 366 to 375, the class ShopifyTransformers is missing the definition of the locationMappings property, which causes runtime errors when getWarehouseId and isLocationMapped methods try to access it. To fix this, add a locationMappings property to the class and initialize it properly, or if these methods are unused, remove them along with any references to locationMappings to prevent errors.

- In lib/integrations/webhook-handler.ts around lines 249 to 251, the error thrown when parsing the webhook payload lacks context about the platform or specific failure details. Modify the error message to include the platform name or relevant identifying information along with the original error to provide clearer debugging context.

- In lib/integrations/webhook-handler.ts around lines 437 to 446, the database query lacks error handling, which could cause the method to return false on query failure and allow duplicates. Wrap the query in a try-catch block, catch any errors thrown during the query, and handle them appropriately, such as logging the error and returning a safe default or rethrowing. This ensures that query failures do not lead to incorrect duplicate detection results.

- In lib/integrations/webhook-handler.ts between lines 49 and 72, the code logs headers that may contain sensitive information. To fix this, identify headers that could hold sensitive data (like authentication tokens or API keys) and either exclude them from debugInfo.headers or replace their values with a redacted placeholder before logging. Update the relevantHeaders processing to filter or redact sensitive headers accordingly.

- In lib/monitoring/accuracy-checker.ts between lines 640-652 and 667-678, the methods getLastSyncData() and getSyncedPrice() currently return mock data instead of querying the actual sync history. To fix this, replace the mock return values with proper database queries that fetch the last synced data and synced price based on the integrationId, entityType, and identifier parameters. Use the appropriate database client or ORM methods to retrieve this data accurately from the sync history tables.

- In lib/monitoring/accuracy-checker.ts at line 87, the progress calculation uses a fixed value of 10,000 which may not match the actual total records, causing inaccurate progress reporting. To fix this, determine the actual total number of records to process before starting and replace the hardcoded 10,000 with this dynamic total in the progress calculation. This will ensure the progress percentage reflects the true processing status.

- In lib/monitoring/alert-manager.ts between lines 148 and 163, the getRecipientForChannel method currently returns hardcoded placeholder recipients, which risks sending notifications to incorrect addresses. Update this method to be asynchronous and fetch the actual recipient from the organization_notification_settings table using the organization_id from the rule and the channel as query parameters. If no recipient is found, throw an error indicating the missing configuration. This ensures recipients are dynamically resolved from organization settings before sending alerts.

- In lib/monitoring/alert-manager.ts around lines 331 to 342, the acknowledgeAlert method lacks checks for user authorization and alert state validity before updating. Modify the method to first fetch the alert by alertId, verify the userId has permission to acknowledge it, and confirm the alert is in a state that allows acknowledgment. Only proceed with the update if these conditions are met; otherwise, return false or throw an appropriate error.

- In lib/monitoring/alert-manager.ts around lines 75 to 82, the metadata included in alert messages is not sanitized, risking exposure of sensitive information. Implement a filtering mechanism to exclude or mask sensitive fields from config.metadata before adding them to the lines array. Ensure only non-sensitive metadata keys and values are formatted and included in the alert message.

- In lib/monitoring/alert-manager.ts around lines 414 to 424, the current code clears all metadata when reactivating expired alerts, which may remove important non-snooze information. Modify the update logic to preserve existing metadata except for snooze-related fields, merging or selectively clearing only those. Additionally, add error handling for the update operation to catch and log any failures during the database update.

- In lib/monitoring/alert-manager.ts between lines 8 and 63, the createAlert method lacks input validation and uses generic error handling that hinders debugging. Add validation checks for required fields in the config parameter before proceeding, returning descriptive errors if validation fails. Replace generic catch error handling with more specific error captures and return detailed error information instead of null to help callers handle failures better. Also, improve logging by including contextual details about the failure points.

- In lib/monitoring/anomaly-detector.ts around lines 408 to 418, the explanation message always shows "increase" because the condition changeRate > 1 is always true there. Fix this by adjusting the logic to correctly reflect whether the change is an increase or decrease based on the actual value of changeRate relative to 1, ensuring the explanation string dynamically matches the direction of the change.

- In lib/monitoring/anomaly-detector.ts around lines 319 to 322, the confidence calculation risks division by zero if dayCount or overallVariance is zero. Add checks to ensure dayCount and overallVariance are greater than zero before performing the division. If either is zero, set confidence to zero or handle the case appropriately to avoid runtime errors.

- In lib/monitoring/anomaly-detector.ts around lines 211 to 226, the calculation of stalePercentage divides by discrepancies.length without checking if it is zero, which can cause a division by zero error. Fix this by adding a condition to check if discrepancies.length is greater than zero before performing the division; if it is zero, set stalePercentage to zero or handle accordingly to avoid the error.

- In lib/monitoring/auto-remediation.ts around lines 314 to 329, the code verifies if the update succeeded but does not revert the change if verification fails. To fix this, implement a rollback mechanism that resets the field to the original currentValue when updateVerified is false. This ensures data integrity by undoing unsuccessful updates automatically before returning the result.

- In lib/monitoring/notification-service.ts around lines 126 to 127, the notification_settings are cast to any, which removes type safety. Define a proper TypeScript interface or type that matches the structure of notification_settings and use that type instead of any to ensure type safety and better code clarity.

- In lib/monitoring/notification-service.ts around lines 418 to 426, the fetch call to the webhookUrl lacks a timeout, which can cause the request to hang indefinitely. To fix this, create an AbortController, set a timeout to call abort on it after a specified duration, and pass the controller's signal to the fetch options. Ensure to clear the timeout after the fetch completes to avoid leaks.

- In lib/monitoring/types.ts between lines 18 and 50, the property naming for confidence is inconsistent: `DiscrepancyResult` uses `confidence` while `Discrepancy` uses `confidenceScore`. To fix this, rename one of the properties so both interfaces use the same name, either `confidence` or `confidenceScore`, ensuring consistency across the codebase.

- In lib/security/csrf.ts around lines 20 to 24, the code retrieves the referer header but does not use it for validation, and it allows requests without an origin header to pass. To fix this, add validation logic that checks both the origin and referer headers against expected values, and require the origin header to be present for all requests, rejecting those without it to strengthen request validation.

- In lib/security/csrf.ts around lines 25 to 32, the origin validation is insecure because it uses the protocol from the untrusted origin header, allowing bypass via crafted origins. Fix this by extracting the protocol from the host or a trusted source instead of the origin header, and validate that the entire origin matches the expected trusted origin string without relying on parts of the untrusted input.

- In supabase/migrations/007_integrations.sql around lines 375 to 376, the calculation of v_window_start always truncates the current time to the hour, ignoring the p_window_seconds parameter. To fix this, adjust the calculation to truncate the current timestamp to the nearest multiple of p_window_seconds instead of always truncating to the hour, ensuring the window respects the configured window size for accurate rate limiting.

- In supabase/migrations/010_shopify_integration.sql around lines 10 to 11, the storefront_access_token field stores sensitive tokens as plain text, which is insecure. To fix this, enable PostgreSQL's pgcrypto extension in the database and modify the schema to store encrypted tokens using pgcrypto functions, or alternatively, implement encryption in the application layer before saving tokens to the database. This ensures tokens are encrypted at rest and enhances security.

- In supabase/migrations/012_sync_engine.sql at line 318, the JSON path syntax is incorrect because the ->> operator returns text and cannot be chained with another ->>. To fix this, replace the chained ->> operators with a single -> operator to access the nested JSON object first, then use ->> to extract the text value. Adjust the expression to correctly navigate the JSON structure without chaining ->> operators.

- In supabase/migrations/20250127_add_organization_id_to_shopify_tables.sql around lines 111 to 117, the UPDATE statement that backfills organization_id is not wrapped in a transaction. To fix this, enclose the UPDATE statement within a BEGIN and COMMIT block to ensure atomicity and consistency, matching the pattern used for other table updates in the migration.

- In types/netsuite.types.ts around lines 120 to 132, the Zod schema netsuiteItemSchema lacks validation for custom fields defined in the NetSuiteItem interface, causing a mismatch between TypeScript types and runtime validation. Update the schema to include and validate all custom fields present in the NetSuiteItem interface, ensuring the schema fully represents the interface structure for consistent type safety and validation.