Fix the following issues. The issues can be from different files or can overlap on same lines in one file.

- In PRPs/Phase 5/PRP-016A.md around lines 15 to 16 and 84 to 86, the usage of createClient() is inconsistent, sometimes treated as synchronous and other times awaited as asynchronous. Review the actual createClient() function signature to confirm if it returns a promise or not. Then update all references to createClient() in these lines to consistently either include or omit the await keyword accordingly, ensuring the code matches the true behavior of createClient() and avoids confusion or bugs.

- In app/(dashboard)/customers/[id]/pricing/contracts/page.tsx between lines 43 and 82, the error handling for fetching customer data returns null silently, while the contract query logs errors to the console. To improve consistency, add error logging for the customer query error similar to the contract query by logging the customerError before returning null. This ensures all errors are logged for easier debugging.

- In app/(dashboard)/integrations/shopify/setup/page.tsx around lines 22 to 31, the error handling for fetching the user profile does not distinguish between database errors and missing profiles. Update the code to check if the error is due to no profile found (e.g., handle a "not found" or empty result case separately) and redirect accordingly, while logging and handling genuine database errors differently, such as showing an error message or retrying, instead of redirecting immediately.

- In app/(dashboard)/integrations/shopify/setup/page.tsx around lines 38 to 48, the database query to check for existing integrations lacks error handling. Modify the code to capture and check for errors returned by the supabase query. If an error occurs, handle it appropriately, such as logging the error or showing a user-friendly message, and prevent further execution that depends on the query result.

- In app/actions/customer-pricing.ts around lines 128 to 134, the code updates a contract without verifying if the contract belongs to the user's organization, risking unauthorized updates. Before calling the update RPC, add a query to fetch the contract by ID including the related customer's organization_id, then check if the fetched contract exists and if its organization_id matches the user's organization_id. If not, throw an error to prevent unauthorized access. This ensures only contracts owned by the user's organization can be updated.

- In app/api/bulk/cancel/route.ts at line 16, the call to request.json() lacks error handling for malformed JSON input. Wrap the await request.json() call in a try-catch block to catch any JSON parsing errors. In the catch block, return an appropriate error response indicating invalid JSON input to prevent the error from bypassing validation logic.

- In app/api/bulk/rollback/route.ts at line 1, there is an import inconsistency where `createServerClient` is imported but `createClient()` is called in the code. To fix this, replace all calls to `createClient()` with `createServerClient()` to match the import and ensure consistent usage.

- In app/api/bulk/rollback/route.ts around lines 52 to 54, the rollbackOperation is called with a fire-and-forget pattern that may cause silent failures. Modify the code to return the promise from rollbackOperation or properly await it, and implement error handling that ensures any errors are tracked and surfaced appropriately instead of just logging them to the console.

- In app/api/bulk/rollback/route.ts around lines 26 to 38, the code fetches the operation without verifying it belongs to the user's organization, risking unauthorized access. Fix this by adding a filter to the Supabase query to check that the operation's organization ID matches the user's organization ID before proceeding. If the organization IDs do not match, return a 403 Forbidden response to prevent unauthorized rollback actions.

- In app/api/bulk/upload/route.ts around lines 54 to 58, the current CSV file validation only checks basic validity but lacks file size limits and content type verification. Update the validateCSVFile function to include checks that the file size does not exceed a defined safe limit and that the file's MIME type or extension matches expected CSV formats. This will prevent security risks and resource exhaustion by rejecting files that are too large or of an incorrect type.

- In app/api/bulk/upload/route.ts around lines 81 to 89, the current error handling returns raw error messages in the API response, which may expose sensitive information. Modify the code to sanitize error messages by returning a generic error message like "Internal server error" for all cases, avoiding sending the actual error.message in the response. Keep detailed error logging on the server side only.

- In app/api/bulk/upload/route.ts at line 1, the import statement uses createServerClient but the code calls createClient() on line 8, causing a runtime error. To fix this, update the function call on line 8 to use createServerClient() to match the import and avoid the inconsistency.

- In app/api/bulk/upload/route.ts around lines 65 to 66, the use of 'as any' for operationType and entityType disables TypeScript's type checking, which is unsafe. Replace these casts by defining and using appropriate TypeScript types or enums for operationType and entityType, ensuring the variables conform to these types without using 'any'.

- In app/api/integrations/netsuite/test/route.ts at line 69, the code uses a type assertion 'as NetSuiteIntegrationConfig' without validating the data structure, which can hide type mismatches. To fix this, implement a runtime validation function that checks if the object conforms to the NetSuiteIntegrationConfig interface by verifying required fields and their types. Then, before using the config, call this validation function and handle invalid cases appropriately, such as returning an error response.

- In app/api/integrations/netsuite/test/route.ts around lines 115 to 118, the NetSuiteAPIClient is instantiated multiple times in the tests, causing unnecessary duplication. To fix this, move the creation of the apiClient instance to after line 71 so it is initialized once for all tests. Then update all test cases to reuse this single apiClient instance instead of creating new ones.

- In app/api/integrations/netsuite/test/route.ts at lines 234-235, replace the use of 'any' type in the callback parameter of the some() method with the proper 'TestResult' type. This involves importing or referencing the existing 'TestResult' interface and using it to type the parameter instead of 'any' to improve type safety and leverage TypeScript's type inference.

- In app/api/integrations/netsuite/test/route.ts around lines 237 to 242, the properties overall_status and message are assigned to the testResults object but are missing from the TestResults interface. To fix this, update the TestResults interface by adding overall_status as a string and message as a string to ensure type consistency and prevent TypeScript errors.

- In app/api/webhooks/netsuite/route.ts between lines 127 and 256, the webhook processing updates multiple tables without using a database transaction, risking partial updates if an error occurs mid-process. To fix this, refactor the code to wrap all database operations within a single transaction, either by using Supabase's transaction support or creating a stored procedure that handles the entire webhook processing atomically. This ensures that either all updates succeed or none are applied, maintaining data consistency.

- In components/features/bulk/bulk-progress-tracker.tsx around lines 109 to 125, the handleRollback function allows multiple rollback requests if triggered repeatedly. Add a guard at the start of the function to check if a rollback is already in progress (using isRollingBack state) and return early if true. This prevents sending multiple requests when the button is clicked multiple times quickly.

- In components/features/integrations/integrations-list.tsx at line 213, the code incorrectly compares syncMutation.variables, which is an object, directly to integration.id, a string. To fix this, access the specific property within syncMutation.variables that holds the integration id (e.g., syncMutation.variables.id) and compare that to integration.id instead.

- In components/features/monitoring/discrepancy-table.tsx around lines 152 to 158, the "View All Discrepancies" button is rendered but lacks an onClick handler or navigation logic, making it non-functional. Add an onClick handler to the Button that triggers navigation to the full discrepancies view, or replace the Button with a Link component pointing to the appropriate route for viewing all discrepancies. Ensure the handler or Link correctly integrates with the app's routing system.

- In components/features/monitoring/discrepancy-table.tsx around lines 117 to 119, remove the unsafe 'as any' type assertion on the result of getSeverityColor. Instead, update the getSeverityColor function to return a value whose type matches the expected variant prop type of the Badge component, ensuring type safety without bypassing TypeScript checks.

- In components/features/pricing/contract-items-section.tsx around lines 77 to 85, the remove button lacks an aria-label, which reduces accessibility for screen reader users. Add an aria-label attribute to the Button component with a descriptive value such as "Remove item" to improve accessibility.

- In components/features/pricing/contract-items-section.tsx at line 38, the onUpdateItem function uses 'any' for the value parameter, which reduces type safety. Replace 'any' with a union type that includes all possible types the value can take based on the fields of ContractItemForm, such as string | number | boolean, or other relevant types, to improve type checking and maintainability.

- In components/features/sync/sync-schedules-list.tsx around lines 137 to 141, replace the native browser confirm() call with a custom confirmation dialog component from your UI design system. Implement the dialog to prompt the user for confirmation before deleting a schedule, and handle the user's response to either proceed with or cancel the deletion. This will ensure consistent styling and a better user experience aligned with the rest of the application.

- In components/ui/file-upload.tsx around lines 53 to 60, the catch block only logs errors to the console without providing user feedback. Introduce a state variable to hold error messages, set this state with a user-friendly error message inside the catch block, and update the UI to display this error message below the upload area so users are informed about validation failures or upload issues.

- In components/ui/file-upload.tsx around lines 42 to 50, improve the file type validation by refining the regex pattern creation to properly escape special characters and replace wildcards correctly, avoiding invalid regex patterns. Also, ensure the file extension comparison is fully case-insensitive by consistently converting both the file name and the accepted extensions to lowercase before comparison.

- In hooks/use-accuracy-monitor.ts at line 30, the Supabase client is created on every render, causing unnecessary overhead. Wrap the createClient() call inside a useMemo hook to memoize the client instance, ensuring it is only created once per component lifecycle or when dependencies change.

- In lib/email/price-approval-notification.ts around lines 324 to 328, the current email validation regex is too simplistic and may incorrectly validate or reject email addresses. Replace the regex validation with a more robust approach by using a validation library like zod. Import z from 'zod', define an emailSchema using z.string().email(), and then parse the email address with emailSchema.parse(to) inside a try-catch block to throw an error if the email is invalid.

- In lib/email/price-approval-notification.ts around lines 263 to 271, the current date parsing using a native Date constructor inside an IIFE may not reliably handle malformed or unexpected date strings despite the try-catch. To fix this, replace the native Date parsing with a more robust date parsing library like date-fns or moment, or add explicit validation of the date format before parsing. This ensures safer handling of edge cases and prevents potential runtime errors or invalid date outputs.

- In lib/email/price-approval-notification.ts at line 309, the text version formats the date using new Date() without error handling, unlike the HTML version which uses try-catch. To fix this, wrap the date parsing and formatting in a try-catch block similar to the HTML version to handle potential invalid dates gracefully and ensure consistent error handling between both versions.

- In lib/monitoring/accuracy-scorer.ts around lines 178 to 184, the code currently estimates records per entity type by dividing total records evenly, which can lead to inaccurate scoring. To fix this, replace the estimation with a query that fetches the actual count of records for each entity type from the database. Use these actual counts to calculate the entityScore for each entity type, ensuring the accuracy breakdown reflects real data distribution.

- In package.json at line 111, the Twilio SDK version is incorrectly set to "^5.8.0", which does not exist. Change the version to the latest stable release "5.5.2". After updating the version, run `npm install` to update dependencies and test SMS notification features to ensure they function correctly.

- In supabase/migrations/013_update_contract_items_rpc.sql around lines 26 to 32, the code directly casts JSONB fields without validating their presence or structure, which can cause runtime errors. Add checks to ensure each required JSONB field exists and is of the expected type before casting, using conditional expressions or JSONB functions to validate the structure and handle missing or malformed data gracefully.

- In supabase/migrations/013_update_contract_items_rpc.sql around lines 4 to 11, the function update_contract_items lacks validation for the p_contract_id parameter. Add input validation at the start of the function to check if p_contract_id is NULL and raise an exception if so. Then, verify that a contract with the given p_contract_id exists in the contracts table; if not, raise an exception to prevent further execution with invalid input.

- In supabase/migrations/014_create_shopify_integration_rpc.sql around lines 4 to 19, the function uses SECURITY DEFINER which can bypass row-level security, so you need to add input validation for parameters like p_shop_domain. Add checks at the start of the function to ensure p_shop_domain is not null or empty and matches the expected Shopify domain pattern using a regex. Also, review the function owner's privileges to ensure they are minimal and sanitize parameters to prevent injection risks.

- In supabase/migrations/014_create_shopify_integration_rpc.sql around lines 70 to 79, the credentials are stored as plaintext JSONB, which risks exposing sensitive access tokens. Modify the code to encrypt the access tokens before storing them by applying an encryption function (e.g., encrypt()) to each token value within jsonb_build_object. Also, ensure the database enforces strict access controls and audit logging on the integration_credentials table to protect sensitive data.

- In supabase/migrations/014_update_contract_with_items_rpc.sql around lines 23 to 24, the direct casting of signed_date from JSONB to DATE can fail if the date string is invalid, causing the transaction to fail without clear errors. Replace the direct cast with a CASE statement that checks if the signed_date is NULL or empty string and returns NULL in those cases; otherwise, cast the value to DATE. This defensive approach prevents errors from invalid date strings during conversion.

- In supabase/migrations/20250127_update_shopify_sync_state_constraint.sql between lines 4 and 21, the migration adds a new constraint before updating existing data, which may cause failure if singular entity types exist. To fix this, reorder the operations so that the UPDATE statement converting singular entity types to plural runs before adding the new constraint, ensuring all data complies with the constraint at the time it is added.

- In types/netsuite.types.ts around lines 184 to 186, the isNetSuiteApiError type guard currently only checks for the presence of 'type' and 'status' properties, which may lead to false positives. Enhance the type guard by adding checks for additional specific properties unique to NetSuiteApiError, such as 'code' or 'message', to make the type guard more precise and robust.

- In types/shopify-integration.types.ts between lines 17 and 21, the shop_domain property is currently optional but should be made required because every Shopify store has a domain. Remove the optional modifier (?) from shop_domain in the ShopifyIntegrationConfig interface to ensure it is always provided.
