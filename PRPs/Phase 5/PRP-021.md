# PRP-021: AI-Powered Insights

## Goal
Build intelligent, AI-powered insights that provide demand forecasting, reorder point suggestions, price optimization recommendations, anomaly detection, trend analysis, and natural language insights to help businesses make data-driven decisions.

## Why This Matters
- **Predictive Power**: Move from reactive to proactive inventory management
- **Cost Reduction**: Optimize stock levels to reduce holding costs and prevent stockouts
- **Revenue Optimization**: AI-driven pricing recommendations maximize profit margins
- **Early Warning**: Detect anomalies before they become critical issues
- **Accessible Insights**: Natural language summaries make data accessible to all users

## What We're Building
A comprehensive AI-powered insights system featuring:
1. Demand forecasting using time series analysis
2. Intelligent reorder point suggestions
3. Dynamic price optimization recommendations
4. Real-time anomaly detection
5. Trend analysis with pattern recognition
6. Natural language insights and summaries

## Context & References

### Codebase Patterns
- **Analytics Foundation**: `lib/analytics/calculate-metrics.ts` from PRP-018 - Existing metrics calculation
- **Performance Monitoring**: `lib/realtime/performance-monitor.ts` - Real-time metric patterns
- **Report Generation**: From PRP-019 - Data aggregation and processing patterns
- **Bulk Operations**: From PRP-017 - Stream processing for large datasets
- **Database Schema**: Analytics metrics storage from PRP-018

### External Documentation
- **Vercel AI SDK**: https://sdk.vercel.ai/docs - Official AI SDK documentation
- **OpenAI API**: https://platform.openai.com/docs/api-reference
- **TensorFlow.js**: https://www.tensorflow.org/js/guide
- **ARIMA.js**: https://github.com/zemlyansky/arima
- **Time Series Guide**: https://www.tensorflow.org/tutorials/structured_data/time_series
- **Supabase Edge Functions**: https://supabase.com/docs/guides/functions

## Implementation Blueprint

### Phase 1: Database Schema Extensions

```sql
-- AI predictions storage
CREATE TABLE ai_predictions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id) NOT NULL,
  prediction_type TEXT NOT NULL CHECK (prediction_type IN ('demand', 'reorder', 'price', 'anomaly')),
  entity_type TEXT NOT NULL CHECK (entity_type IN ('product', 'warehouse', 'category')),
  entity_id UUID NOT NULL,
  
  -- Prediction details
  prediction_date DATE NOT NULL,
  prediction_value JSONB NOT NULL,
  confidence_score DECIMAL(3,2) CHECK (confidence_score >= 0 AND confidence_score <= 1),
  
  -- Model metadata
  model_version TEXT NOT NULL,
  model_parameters JSONB DEFAULT '{}',
  
  -- Time range
  prediction_start DATE NOT NULL,
  prediction_end DATE NOT NULL,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ, -- For cache management
  
  UNIQUE(organization_id, prediction_type, entity_type, entity_id, prediction_date)
);

-- AI insights log
CREATE TABLE ai_insights (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id) NOT NULL,
  insight_type TEXT NOT NULL CHECK (insight_type IN ('summary', 'recommendation', 'alert', 'trend')),
  
  -- Insight content
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  severity TEXT CHECK (severity IN ('info', 'warning', 'critical')),
  
  -- Related data
  related_entities JSONB DEFAULT '[]', -- Array of {type, id, name}
  metrics JSONB DEFAULT '{}',
  
  -- Actions
  recommended_actions JSONB DEFAULT '[]',
  
  -- Tracking
  is_read BOOLEAN DEFAULT FALSE,
  is_dismissed BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  valid_until TIMESTAMPTZ
);

-- Training data snapshots for ML models
CREATE TABLE ml_training_data (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id) NOT NULL,
  model_type TEXT NOT NULL,
  
  -- Training data
  data JSONB NOT NULL,
  feature_names TEXT[],
  
  -- Model performance
  metrics JSONB DEFAULT '{}', -- MAE, RMSE, R2, etc.
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_ai_predictions_lookup ON ai_predictions(organization_id, entity_type, entity_id, prediction_type);
CREATE INDEX idx_ai_predictions_date ON ai_predictions(prediction_date DESC);
CREATE INDEX idx_ai_insights_org_date ON ai_insights(organization_id, created_at DESC);
CREATE INDEX idx_ai_insights_unread ON ai_insights(organization_id, is_read) WHERE is_read = FALSE;

-- RLS
ALTER TABLE ai_predictions ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_insights ENABLE ROW LEVEL SECURITY;
ALTER TABLE ml_training_data ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own AI predictions" ON ai_predictions
  FOR SELECT USING (
    organization_id = (SELECT organization_id FROM user_profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Users can view own AI insights" ON ai_insights
  FOR SELECT USING (
    organization_id = (SELECT organization_id FROM user_profiles WHERE user_id = auth.uid())
  );

CREATE POLICY "Users can update own AI insights" ON ai_insights
  FOR UPDATE USING (
    organization_id = (SELECT organization_id FROM user_profiles WHERE user_id = auth.uid())
  );
```

### Phase 2: AI Service Layer

```typescript
// lib/ai/ai-service.ts
import { createServerClient } from '@/lib/supabase/server'
import { OpenAI } from 'openai'
import { generateText, streamText } from 'ai'
import { openai } from '@ai-sdk/openai'
import type { 
  DemandForecast, 
  ReorderSuggestion, 
  PriceRecommendation,
  AnomalyAlert,
  TrendAnalysis
} from '@/types/ai.types'

export class AIService {
  private supabase: ReturnType<typeof createServerClient>
  private openai: OpenAI

  constructor() {
    this.supabase = createServerClient()
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY!
    })
  }

  async generateInsights(
    organizationId: string,
    dateRange: { from: Date; to: Date }
  ): Promise<{
    summary: string
    recommendations: string[]
    alerts: AnomalyAlert[]
  }> {
    // Fetch relevant data
    const [inventory, orders, pricing] = await Promise.all([
      this.getInventoryData(organizationId, dateRange),
      this.getOrderData(organizationId, dateRange),
      this.getPricingData(organizationId, dateRange)
    ])

    // Generate insights using AI
    const { text } = await generateText({
      model: openai('gpt-4o'),
      system: `You are an expert business analyst for a B2B e-commerce company. 
               Analyze the provided data and generate actionable insights.
               Focus on inventory optimization, pricing opportunities, and anomalies.`,
      prompt: `Analyze this business data and provide insights:
               
               Inventory Summary:
               ${JSON.stringify(inventory.summary)}
               
               Order Patterns:
               ${JSON.stringify(orders.patterns)}
               
               Pricing Data:
               ${JSON.stringify(pricing.overview)}
               
               Provide:
               1. Executive summary (2-3 sentences)
               2. Top 3-5 actionable recommendations
               3. Any critical alerts or anomalies`,
      temperature: 0.7,
      maxTokens: 1000
    })

    // Parse AI response
    const insights = this.parseAIResponse(text)

    // Store insights
    await this.storeInsights(organizationId, insights)

    return insights
  }

  async streamInsights(
    organizationId: string,
    context: any
  ): Promise<ReadableStream> {
    const result = await streamText({
      model: openai('gpt-4o'),
      system: 'You are an AI assistant helping with inventory and pricing decisions.',
      messages: context.messages,
      temperature: 0.7,
      maxTokens: 500
    })

    return result.toTextStreamResponse()
  }

  private async getInventoryData(
    organizationId: string,
    dateRange: { from: Date; to: Date }
  ) {
    const { data } = await this.supabase
      .from('inventory_snapshots')
      .select('*')
      .eq('organization_id', organizationId)
      .gte('snapshot_date', dateRange.from.toISOString())
      .lte('snapshot_date', dateRange.to.toISOString())

    return {
      summary: {
        totalProducts: data?.length || 0,
        lowStockItems: data?.filter(i => i.quantity < 10).length || 0,
        totalValue: data?.reduce((sum, i) => sum + (i.value || 0), 0) || 0
      },
      data
    }
  }

  private async getOrderData(
    organizationId: string,
    dateRange: { from: Date; to: Date }
  ) {
    const { data } = await this.supabase
      .from('orders')
      .select('*')
      .eq('organization_id', organizationId)
      .gte('created_at', dateRange.from.toISOString())
      .lte('created_at', dateRange.to.toISOString())

    // Calculate patterns
    const patterns = {
      totalOrders: data?.length || 0,
      averageOrderValue: data?.length 
        ? data.reduce((sum, o) => sum + (o.total || 0), 0) / data.length 
        : 0,
      peakDays: this.identifyPeakDays(data || [])
    }

    return { patterns, data }
  }

  private async getPricingData(
    organizationId: string,
    dateRange: { from: Date; to: Date }
  ) {
    const { data } = await this.supabase
      .from('pricing_history')
      .select('*')
      .eq('organization_id', organizationId)
      .gte('created_at', dateRange.from.toISOString())
      .lte('created_at', dateRange.to.toISOString())

    return {
      overview: {
        priceChanges: data?.length || 0,
        averageMargin: this.calculateAverageMargin(data || [])
      },
      data
    }
  }

  private parseAIResponse(text: string): {
    summary: string
    recommendations: string[]
    alerts: AnomalyAlert[]
  } {
    // Parse structured response from AI
    // This is a simplified version - in production, use more robust parsing
    const lines = text.split('\n')
    
    return {
      summary: lines[0] || '',
      recommendations: lines.slice(2, 7).filter(l => l.trim()),
      alerts: [] // Would parse alerts from response
    }
  }

  private async storeInsights(
    organizationId: string,
    insights: any
  ): Promise<void> {
    const insightRecords = [
      {
        organization_id: organizationId,
        insight_type: 'summary',
        title: 'Daily Business Summary',
        content: insights.summary,
        severity: 'info'
      },
      ...insights.recommendations.map((rec: string) => ({
        organization_id: organizationId,
        insight_type: 'recommendation',
        title: 'AI Recommendation',
        content: rec,
        severity: 'info'
      }))
    ]

    await this.supabase
      .from('ai_insights')
      .insert(insightRecords)
  }

  private identifyPeakDays(orders: any[]): string[] {
    // Implement peak day identification logic
    return []
  }

  private calculateAverageMargin(pricingData: any[]): number {
    // Implement margin calculation
    return 0
  }
}
```

### Phase 3: Demand Forecasting Module

```typescript
// lib/ai/demand-forecasting.ts
import * as tf from '@tensorflow/tfjs'
import ARIMA from 'arima'
import { createServerClient } from '@/lib/supabase/server'
import type { DemandForecast, TimeSeriesData } from '@/types/ai.types'

export class DemandForecaster {
  private supabase: ReturnType<typeof createServerClient>
  private model: tf.Sequential | null = null

  constructor() {
    this.supabase = createServerClient()
  }

  async forecastDemand(
    productId: string,
    warehouseId: string,
    horizonDays: number = 30
  ): Promise<DemandForecast> {
    // Fetch historical data
    const historicalData = await this.getHistoricalDemand(productId, warehouseId)

    if (historicalData.length < 30) {
      // Use simple moving average for products with limited history
      return this.simpleMovingAverageForecast(historicalData, horizonDays)
    }

    // Prepare time series data
    const timeSeries = this.prepareTimeSeries(historicalData)

    // Try multiple forecasting methods
    const [arima, lstm, prophet] = await Promise.all([
      this.arimaForecast(timeSeries, horizonDays),
      this.lstmForecast(timeSeries, horizonDays),
      this.prophetStyleForecast(timeSeries, horizonDays)
    ])

    // Ensemble the predictions
    const ensembledForecast = this.ensemblePredictions([arima, lstm, prophet])

    // Calculate confidence intervals
    const confidence = this.calculateConfidence(ensembledForecast, historicalData)

    // Store prediction
    await this.storePrediction({
      productId,
      warehouseId,
      forecast: ensembledForecast,
      confidence,
      horizonDays
    })

    return {
      productId,
      warehouseId,
      predictions: ensembledForecast,
      confidence,
      method: 'ensemble',
      generatedAt: new Date()
    }
  }

  private async getHistoricalDemand(
    productId: string,
    warehouseId: string
  ): Promise<TimeSeriesData[]> {
    const { data, error } = await this.supabase
      .from('order_items')
      .select(`
        quantity,
        created_at,
        orders!inner(
          organization_id,
          warehouse_id
        )
      `)
      .eq('product_id', productId)
      .eq('orders.warehouse_id', warehouseId)
      .gte('created_at', new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString())
      .order('created_at', { ascending: true })

    if (error) throw error

    // Aggregate by day
    const dailyDemand = new Map<string, number>()
    
    data?.forEach(item => {
      const date = new Date(item.created_at).toISOString().split('T')[0]
      dailyDemand.set(date, (dailyDemand.get(date) || 0) + item.quantity)
    })

    return Array.from(dailyDemand.entries()).map(([date, quantity]) => ({
      date: new Date(date),
      value: quantity
    }))
  }

  private prepareTimeSeries(data: TimeSeriesData[]): number[] {
    // Fill missing dates with zeros
    const fullSeries: number[] = []
    const startDate = data[0].date
    const endDate = data[data.length - 1].date
    
    const dateMap = new Map(data.map(d => [d.date.toISOString().split('T')[0], d.value]))
    
    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
      const dateStr = d.toISOString().split('T')[0]
      fullSeries.push(dateMap.get(dateStr) || 0)
    }
    
    return fullSeries
  }

  private async arimaForecast(
    timeSeries: number[],
    horizonDays: number
  ): Promise<number[]> {
    // Auto-fit ARIMA model
    const arima = new ARIMA({
      auto: true,
      data: timeSeries,
      p: 5, // max p
      d: 2, // max d
      q: 5, // max q
    })

    // Predict future values
    const [pred, errors] = arima.predict(horizonDays)
    
    return pred
  }

  private async lstmForecast(
    timeSeries: number[],
    horizonDays: number
  ): Promise<number[]> {
    // Prepare data for LSTM
    const windowSize = 7 // Use last 7 days to predict next day
    const X: number[][] = []
    const y: number[] = []
    
    for (let i = windowSize; i < timeSeries.length; i++) {
      X.push(timeSeries.slice(i - windowSize, i))
      y.push(timeSeries[i])
    }

    // Normalize data
    const max = Math.max(...timeSeries)
    const min = Math.min(...timeSeries)
    const normalizedX = X.map(window => 
      window.map(val => (val - min) / (max - min))
    )
    const normalizedY = y.map(val => (val - min) / (max - min))

    // Build LSTM model if not exists
    if (!this.model) {
      this.model = tf.sequential({
        layers: [
          tf.layers.lstm({
            units: 50,
            returnSequences: true,
            inputShape: [windowSize, 1]
          }),
          tf.layers.lstm({ units: 50 }),
          tf.layers.dense({ units: 1 })
        ]
      })

      this.model.compile({
        optimizer: 'adam',
        loss: 'meanSquaredError'
      })
    }

    // Train model with proper memory management
    if (!this.model) {
      throw new Error('LSTM model not initialized')
    }
    
    const xs = tf.tensor3d(normalizedX.map(x => x.map(v => [v])))
    const ys = tf.tensor2d(normalizedY, [normalizedY.length, 1])
    
    try {
      await this.model.fit(xs, ys, {
        epochs: 50,
        batchSize: 32,
        verbose: 0
      })

      // Make predictions
      const predictions: number[] = []
      let inputWindow = [...normalizedX[normalizedX.length - 1]]
      
      for (let i = 0; i < horizonDays; i++) {
        const input = tf.tensor3d([inputWindow.map(v => [v])])
        const pred = this.model.predict(input) as tf.Tensor
        const predValue = (await pred.data())[0]
        
        predictions.push(predValue * (max - min) + min)
        
        // Slide window
        inputWindow = [...inputWindow.slice(1), predValue]
        
        pred.dispose()
        input.dispose()
      }

      return predictions
    } finally {
      // Ensure tensors are disposed even if an error occurs
      xs.dispose()
      ys.dispose()
    }
  }

  private async prophetStyleForecast(
    timeSeries: number[],
    horizonDays: number
  ): Promise<number[]> {
    // Simplified Prophet-style forecast with trend and seasonality
    // In production, use actual Prophet library or more sophisticated implementation
    
    // Calculate trend
    const n = timeSeries.length
    const x = Array.from({ length: n }, (_, i) => i)
    const y = timeSeries
    
    const xMean = x.reduce((a, b) => a + b) / n
    const yMean = y.reduce((a, b) => a + b) / n
    
    const slope = x.reduce((sum, xi, i) => 
      sum + (xi - xMean) * (y[i] - yMean), 0
    ) / x.reduce((sum, xi) => sum + Math.pow(xi - xMean, 2), 0)
    
    const intercept = yMean - slope * xMean
    
    // Calculate seasonality (weekly pattern)
    const seasonality = new Array(7).fill(0)
    const counts = new Array(7).fill(0)
    
    timeSeries.forEach((value, index) => {
      const dayOfWeek = index % 7
      seasonality[dayOfWeek] += value
      counts[dayOfWeek]++
    })
    
    seasonality.forEach((sum, i) => {
      seasonality[i] = sum / counts[i] - yMean
    })
    
    // Generate forecast
    const predictions: number[] = []
    for (let i = 0; i < horizonDays; i++) {
      const trend = slope * (n + i) + intercept
      const seasonal = seasonality[(n + i) % 7]
      predictions.push(Math.max(0, trend + seasonal))
    }
    
    return predictions
  }

  private ensemblePredictions(predictions: number[][]): number[] {
    // Simple average ensemble
    const ensembled: number[] = []
    const numModels = predictions.length
    
    for (let i = 0; i < predictions[0].length; i++) {
      const sum = predictions.reduce((acc, pred) => acc + pred[i], 0)
      ensembled.push(sum / numModels)
    }
    
    return ensembled
  }

  private calculateConfidence(
    forecast: number[],
    historical: TimeSeriesData[]
  ): number {
    // Calculate confidence based on historical variance
    const values = historical.map(h => h.value)
    const mean = values.reduce((a, b) => a + b) / values.length
    const variance = values.reduce((sum, val) => 
      sum + Math.pow(val - mean, 2), 0
    ) / values.length
    
    const cv = Math.sqrt(variance) / mean // Coefficient of variation
    
    // Higher CV means lower confidence
    return Math.max(0.5, Math.min(0.95, 1 - cv))
  }

  private simpleMovingAverageForecast(
    historical: TimeSeriesData[],
    horizonDays: number
  ): DemandForecast {
    const values = historical.map(h => h.value)
    const avg = values.reduce((a, b) => a + b) / values.length
    
    return {
      productId: '',
      warehouseId: '',
      predictions: new Array(horizonDays).fill(avg),
      confidence: 0.6,
      method: 'moving_average',
      generatedAt: new Date()
    }
  }

  private async storePrediction(prediction: any): Promise<void> {
    await this.supabase
      .from('ai_predictions')
      .insert({
        organization_id: prediction.organizationId,
        prediction_type: 'demand',
        entity_type: 'product',
        entity_id: prediction.productId,
        prediction_date: new Date().toISOString().split('T')[0],
        prediction_value: {
          forecast: prediction.forecast,
          horizonDays: prediction.horizonDays
        },
        confidence_score: prediction.confidence,
        model_version: '1.0.0',
        prediction_start: new Date().toISOString().split('T')[0],
        prediction_end: new Date(
          Date.now() + prediction.horizonDays * 24 * 60 * 60 * 1000
        ).toISOString().split('T')[0]
      })
  }
}
```

### Phase 4: Reorder Point Calculator

```typescript
// lib/ai/reorder-suggestions.ts
import { createServerClient } from '@/lib/supabase/server'
import { DemandForecaster } from './demand-forecasting'
import type { ReorderSuggestion } from '@/types/ai.types'

export class ReorderPointCalculator {
  private supabase: ReturnType<typeof createServerClient>
  private forecaster: DemandForecaster

  constructor() {
    this.supabase = createServerClient()
    this.forecaster = new DemandForecaster()
  }

  async calculateReorderPoints(
    organizationId: string
  ): Promise<ReorderSuggestion[]> {
    // Get all products with inventory
    const { data: inventory } = await this.supabase
      .from('inventory')
      .select(`
        *,
        product:products(*),
        warehouse:warehouses(*)
      `)
      .eq('organization_id', organizationId)

    if (!inventory) return []

    const suggestions: ReorderSuggestion[] = []

    for (const item of inventory) {
      // Get demand forecast
      const forecast = await this.forecaster.forecastDemand(
        item.product_id,
        item.warehouse_id,
        14 // 2 week horizon for reorder calculation
      )

      // Calculate lead time demand
      const leadTimeDays = item.product.lead_time_days || 7
      const avgDailyDemand = forecast.predictions.reduce((a, b) => a + b) / forecast.predictions.length
      const leadTimeDemand = avgDailyDemand * leadTimeDays

      // Calculate safety stock
      const safetyStock = this.calculateSafetyStock(
        forecast.predictions,
        leadTimeDays,
        item.product.service_level || 0.95
      )

      // Reorder point = Lead time demand + Safety stock
      const reorderPoint = Math.ceil(leadTimeDemand + safetyStock)

      // Economic order quantity
      const eoq = this.calculateEOQ(
        avgDailyDemand * 365,
        item.product.order_cost || 50,
        item.product.holding_cost || 0.25 * item.product.unit_price
      )

      suggestions.push({
        productId: item.product_id,
        warehouseId: item.warehouse_id,
        currentStock: item.quantity,
        reorderPoint,
        reorderQuantity: Math.ceil(eoq),
        safetyStock: Math.ceil(safetyStock),
        leadTimeDays,
        confidence: forecast.confidence,
        reasoning: this.generateReasoning({
          avgDailyDemand,
          leadTimeDays,
          serviceLevel: item.product.service_level || 0.95,
          currentStock: item.quantity,
          reorderPoint
        })
      })
    }

    // Store suggestions
    await this.storeSuggestions(organizationId, suggestions)

    return suggestions
  }

  private calculateSafetyStock(
    demandForecast: number[],
    leadTimeDays: number,
    serviceLevel: number
  ): number {
    // Calculate standard deviation of demand
    const mean = demandForecast.reduce((a, b) => a + b) / demandForecast.length
    const variance = demandForecast.reduce((sum, val) => 
      sum + Math.pow(val - mean, 2), 0
    ) / demandForecast.length
    const stdDev = Math.sqrt(variance)

    // Z-score for service level
    const zScore = this.getZScore(serviceLevel)

    // Safety stock = Z-score × σ × √(Lead time)
    return zScore * stdDev * Math.sqrt(leadTimeDays)
  }

  private calculateEOQ(
    annualDemand: number,
    orderCost: number,
    holdingCost: number
  ): number {
    // Economic Order Quantity = √(2 × D × S / H)
    // D = Annual demand
    // S = Order cost
    // H = Holding cost per unit per year
    return Math.sqrt((2 * annualDemand * orderCost) / holdingCost)
  }

  private getZScore(serviceLevel: number): number {
    // Approximate Z-scores for common service levels
    const zScores: Record<number, number> = {
      0.90: 1.28,
      0.95: 1.65,
      0.97: 1.88,
      0.99: 2.33
    }

    // Find closest service level
    const closest = Object.keys(zScores)
      .map(Number)
      .reduce((prev, curr) => 
        Math.abs(curr - serviceLevel) < Math.abs(prev - serviceLevel) ? curr : prev
      )

    return zScores[closest]
  }

  private generateReasoning(params: {
    avgDailyDemand: number
    leadTimeDays: number
    serviceLevel: number
    currentStock: number
    reorderPoint: number
  }): string {
    const { avgDailyDemand, leadTimeDays, serviceLevel, currentStock, reorderPoint } = params
    
    const daysUntilReorder = Math.max(0, (currentStock - reorderPoint) / avgDailyDemand)
    
    return `Based on average daily demand of ${avgDailyDemand.toFixed(1)} units and ` +
           `${leadTimeDays} day lead time, maintaining ${(serviceLevel * 100).toFixed(0)}% ` +
           `service level requires reorder point of ${reorderPoint} units. ` +
           `Current stock will reach reorder point in approximately ${daysUntilReorder.toFixed(0)} days.`
  }

  private async storeSuggestions(
    organizationId: string,
    suggestions: ReorderSuggestion[]
  ): Promise<void> {
    const predictions = suggestions.map(s => ({
      organization_id: organizationId,
      prediction_type: 'reorder',
      entity_type: 'product',
      entity_id: s.productId,
      prediction_date: new Date().toISOString().split('T')[0],
      prediction_value: {
        reorderPoint: s.reorderPoint,
        reorderQuantity: s.reorderQuantity,
        safetyStock: s.safetyStock,
        warehouseId: s.warehouseId
      },
      confidence_score: s.confidence,
      model_version: '1.0.0',
      prediction_start: new Date().toISOString().split('T')[0],
      prediction_end: new Date(
        Date.now() + 30 * 24 * 60 * 60 * 1000
      ).toISOString().split('T')[0]
    }))

    await this.supabase
      .from('ai_predictions')
      .upsert(predictions, {
        onConflict: 'organization_id,prediction_type,entity_type,entity_id,prediction_date'
      })
  }
}
```

### Phase 5: Price Optimization Engine

```typescript
// lib/ai/price-optimization.ts
import { createServerClient } from '@/lib/supabase/server'
import { generateText } from 'ai'
import { openai } from '@ai-sdk/openai'
import type { PriceRecommendation } from '@/types/ai.types'

export class PriceOptimizer {
  private supabase: ReturnType<typeof createServerClient>

  constructor() {
    this.supabase = createServerClient()
  }

  async optimizePricing(
    organizationId: string,
    productIds?: string[]
  ): Promise<PriceRecommendation[]> {
    // Get products to optimize
    const query = this.supabase
      .from('products')
      .select(`
        *,
        inventory(quantity, warehouse_id),
        pricing_history:product_pricing(*)
      `)
      .eq('organization_id', organizationId)

    if (productIds?.length) {
      query.in('id', productIds)
    }

    const { data: products } = await query

    if (!products) return []

    const recommendations: PriceRecommendation[] = []

    for (const product of products) {
      // Get market data
      const marketData = await this.getMarketData(product)
      
      // Get demand elasticity
      const elasticity = await this.calculateDemandElasticity(product)
      
      // Get competitive pricing
      const competitorPrices = await this.getCompetitorPrices(product)
      
      // Calculate optimal price
      const optimalPrice = this.calculateOptimalPrice({
        currentPrice: product.price,
        cost: product.unit_cost,
        elasticity,
        competitorPrices,
        inventoryLevel: product.inventory.reduce((sum: number, i: any) => sum + i.quantity, 0),
        marketData
      })

      // Generate AI reasoning
      const reasoning = await this.generatePricingReasoning({
        product,
        currentPrice: product.price,
        suggestedPrice: optimalPrice,
        elasticity,
        competitorPrices,
        marketData
      })

      recommendations.push({
        productId: product.id,
        currentPrice: product.price,
        suggestedPrice: optimalPrice,
        estimatedImpact: this.estimateRevenueImpact(
          product,
          product.price,
          optimalPrice,
          elasticity
        ),
        confidence: this.calculateConfidence(marketData, competitorPrices),
        reasoning,
        factors: {
          demandElasticity: elasticity,
          competitorAverage: competitorPrices.length 
            ? competitorPrices.reduce((a, b) => a + b) / competitorPrices.length 
            : null,
          inventoryPressure: this.calculateInventoryPressure(product),
          marginTarget: 0.3 // 30% target margin
        }
      })
    }

    // Store recommendations
    await this.storeRecommendations(organizationId, recommendations)

    return recommendations
  }

  private async getMarketData(product: any): Promise<any> {
    // In production, integrate with market data APIs
    // For now, return simulated data
    return {
      trend: 'stable',
      seasonality: 1.0,
      marketGrowth: 0.05
    }
  }

  private async calculateDemandElasticity(product: any): Promise<number> {
    // Get historical price changes and corresponding demand changes
    const { data: priceHistory } = await this.supabase
      .from('product_pricing_history')
      .select('*')
      .eq('product_id', product.id)
      .order('created_at', { ascending: true })
      .limit(10)

    if (!priceHistory || priceHistory.length < 2) {
      // Default elasticity for new products
      return -1.2
    }

    // Simple elasticity calculation
    // In production, use more sophisticated econometric models
    let totalElasticity = 0
    let count = 0

    for (let i = 1; i < priceHistory.length; i++) {
      const priceDiff = (priceHistory[i].price - priceHistory[i-1].price) / priceHistory[i-1].price
      const quantityDiff = (priceHistory[i].quantity_sold - priceHistory[i-1].quantity_sold) / priceHistory[i-1].quantity_sold
      
      if (priceDiff !== 0) {
        totalElasticity += quantityDiff / priceDiff
        count++
      }
    }

    return count > 0 ? totalElasticity / count : -1.2
  }

  private async getCompetitorPrices(product: any): Promise<number[]> {
    // In production, integrate with competitor monitoring APIs
    // For now, return simulated competitor prices
    const basePrice = product.price
    return [
      basePrice * 0.95,
      basePrice * 1.02,
      basePrice * 0.98,
      basePrice * 1.05
    ]
  }

  private calculateOptimalPrice(params: {
    currentPrice: number
    cost: number
    elasticity: number
    competitorPrices: number[]
    inventoryLevel: number
    marketData: any
  }): number {
    const { currentPrice, cost, elasticity, competitorPrices, inventoryLevel } = params

    // Base optimal price using markup pricing
    const targetMargin = 0.3
    const markupPrice = cost / (1 - targetMargin)

    // Adjust for competition
    const avgCompetitorPrice = competitorPrices.length
      ? competitorPrices.reduce((a, b) => a + b) / competitorPrices.length
      : currentPrice
    
    // Adjust for inventory pressure
    const inventoryAdjustment = this.getInventoryPriceAdjustment(inventoryLevel)
    
    // Combine factors
    let optimalPrice = markupPrice * 0.4 + avgCompetitorPrice * 0.4 + currentPrice * 0.2
    
    // Apply inventory adjustment
    optimalPrice *= (1 + inventoryAdjustment)
    
    // Ensure minimum margin
    const minPrice = cost * 1.15 // 15% minimum margin
    optimalPrice = Math.max(optimalPrice, minPrice)
    
    // Round to pricing points
    return Math.round(optimalPrice * 100) / 100
  }

  private getInventoryPriceAdjustment(inventoryLevel: number): number {
    // High inventory = lower price, low inventory = higher price
    if (inventoryLevel > 1000) return -0.05 // 5% discount for high inventory
    if (inventoryLevel < 50) return 0.05 // 5% premium for low inventory
    return 0
  }

  private calculateInventoryPressure(product: any): number {
    const totalInventory = product.inventory.reduce((sum: number, i: any) => sum + i.quantity, 0)
    const avgDailyDemand = 10 // Would calculate from historical data
    const daysOfSupply = totalInventory / avgDailyDemand
    
    if (daysOfSupply > 90) return 0.8 // High pressure to sell
    if (daysOfSupply < 30) return 0.2 // Low pressure
    return 0.5
  }

  private estimateRevenueImpact(
    product: any,
    currentPrice: number,
    newPrice: number,
    elasticity: number
  ): {
    revenueChange: number
    volumeChange: number
  } {
    const priceChange = (newPrice - currentPrice) / currentPrice
    const volumeChange = elasticity * priceChange
    const revenueChange = (1 + priceChange) * (1 + volumeChange) - 1
    
    return {
      revenueChange,
      volumeChange
    }
  }

  private calculateConfidence(marketData: any, competitorPrices: number[]): number {
    // Base confidence on data quality
    let confidence = 0.7
    
    if (competitorPrices.length >= 3) confidence += 0.1
    if (marketData.trend === 'stable') confidence += 0.1
    
    return Math.min(confidence, 0.95)
  }

  private async generatePricingReasoning(params: any): Promise<string> {
    const { text } = await generateText({
      model: openai('gpt-4o'),
      system: 'You are a pricing expert. Provide clear, concise reasoning for price recommendations.',
      prompt: `Explain this price recommendation:
               Product: ${params.product.name}
               Current Price: $${params.currentPrice}
               Suggested Price: $${params.suggestedPrice}
               Demand Elasticity: ${params.elasticity}
               Competitor Average: $${params.competitorPrices.reduce((a: number, b: number) => a + b) / params.competitorPrices.length}
               
               Provide a 2-3 sentence explanation for this pricing recommendation.`,
      temperature: 0.3,
      maxTokens: 150
    })

    return text
  }

  private async storeRecommendations(
    organizationId: string,
    recommendations: PriceRecommendation[]
  ): Promise<void> {
    const predictions = recommendations.map(r => ({
      organization_id: organizationId,
      prediction_type: 'price',
      entity_type: 'product',
      entity_id: r.productId,
      prediction_date: new Date().toISOString().split('T')[0],
      prediction_value: {
        currentPrice: r.currentPrice,
        suggestedPrice: r.suggestedPrice,
        estimatedImpact: r.estimatedImpact,
        factors: r.factors
      },
      confidence_score: r.confidence,
      model_version: '1.0.0',
      prediction_start: new Date().toISOString().split('T')[0],
      prediction_end: new Date(
        Date.now() + 7 * 24 * 60 * 60 * 1000
      ).toISOString().split('T')[0]
    }))

    await this.supabase
      .from('ai_predictions')
      .upsert(predictions, {
        onConflict: 'organization_id,prediction_type,entity_type,entity_id,prediction_date'
      })
  }
}
```

### Phase 6: Anomaly Detection System

```typescript
// lib/ai/anomaly-detection.ts
import { createServerClient } from '@/lib/supabase/server'
import * as tf from '@tensorflow/tfjs'
import type { AnomalyAlert } from '@/types/ai.types'

export class AnomalyDetector {
  private supabase: ReturnType<typeof createServerClient>
  private models: Map<string, tf.Sequential> = new Map()

  constructor() {
    this.supabase = createServerClient()
  }

  async detectAnomalies(
    organizationId: string,
    scope: 'all' | 'inventory' | 'orders' | 'pricing' = 'all'
  ): Promise<AnomalyAlert[]> {
    const anomalies: AnomalyAlert[] = []

    if (scope === 'all' || scope === 'inventory') {
      const inventoryAnomalies = await this.detectInventoryAnomalies(organizationId)
      anomalies.push(...inventoryAnomalies)
    }

    if (scope === 'all' || scope === 'orders') {
      const orderAnomalies = await this.detectOrderAnomalies(organizationId)
      anomalies.push(...orderAnomalies)
    }

    if (scope === 'all' || scope === 'pricing') {
      const pricingAnomalies = await this.detectPricingAnomalies(organizationId)
      anomalies.push(...pricingAnomalies)
    }

    // Store anomalies as insights
    await this.storeAnomalies(organizationId, anomalies)

    return anomalies
  }

  private async detectInventoryAnomalies(
    organizationId: string
  ): Promise<AnomalyAlert[]> {
    const anomalies: AnomalyAlert[] = []

    // Get recent inventory changes
    const { data: changes } = await this.supabase
      .from('inventory_adjustments')
      .select(`
        *,
        inventory(product_id, warehouse_id),
        product:inventory!inner(products(*))
      `)
      .eq('organization_id', organizationId)
      .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString())
      .order('created_at', { ascending: false })

    if (!changes) return anomalies

    // Detect unusual adjustments
    for (const change of changes) {
      // Large single adjustment
      if (Math.abs(change.adjustment) > 100) {
        anomalies.push({
          id: `inv-anomaly-${change.id}`,
          type: 'inventory_spike',
          severity: Math.abs(change.adjustment) > 500 ? 'critical' : 'warning',
          title: 'Unusual Inventory Adjustment',
          description: `Large ${change.adjustment > 0 ? 'increase' : 'decrease'} of ${Math.abs(change.adjustment)} units for ${change.product.name}`,
          detectedAt: new Date(),
          confidence: 0.9,
          relatedEntities: [{
            type: 'product',
            id: change.product_id,
            name: change.product.name
          }],
          suggestedActions: [
            'Verify the adjustment was intentional',
            'Check for data entry errors',
            'Review security logs for unauthorized access'
          ]
        })
      }

      // Repeated adjustments
      const recentAdjustments = changes.filter(c => 
        c.product_id === change.product_id &&
        c.warehouse_id === change.warehouse_id
      )

      if (recentAdjustments.length > 5) {
        anomalies.push({
          id: `inv-pattern-${change.product_id}`,
          type: 'adjustment_pattern',
          severity: 'warning',
          title: 'Frequent Inventory Adjustments',
          description: `${recentAdjustments.length} adjustments in the last 7 days for ${change.product.name}`,
          detectedAt: new Date(),
          confidence: 0.85,
          relatedEntities: [{
            type: 'product',
            id: change.product_id,
            name: change.product.name
          }],
          suggestedActions: [
            'Investigate root cause of frequent adjustments',
            'Consider cycle count accuracy',
            'Review warehouse procedures'
          ]
        })
      }
    }

    // Detect stock level anomalies using statistical methods
    const { data: inventory } = await this.supabase
      .from('inventory')
      .select('*, products(*)')
      .eq('organization_id', organizationId)

    if (inventory) {
      for (const item of inventory) {
        // Zero stock for active products
        if (item.quantity === 0 && item.products.is_active) {
          anomalies.push({
            id: `stock-out-${item.id}`,
            type: 'stock_out',
            severity: 'critical',
            title: 'Product Out of Stock',
            description: `${item.products.name} is completely out of stock`,
            detectedAt: new Date(),
            confidence: 1.0,
            relatedEntities: [{
              type: 'product',
              id: item.product_id,
              name: item.products.name
            }],
            suggestedActions: [
              'Place emergency reorder',
              'Check for pending shipments',
              'Update product availability status'
            ]
          })
        }

        // Excess inventory
        const monthsOfSupply = await this.calculateMonthsOfSupply(item)
        if (monthsOfSupply > 12) {
          anomalies.push({
            id: `excess-${item.id}`,
            type: 'excess_inventory',
            severity: 'warning',
            title: 'Excess Inventory Detected',
            description: `${item.products.name} has ${monthsOfSupply.toFixed(1)} months of supply`,
            detectedAt: new Date(),
            confidence: 0.8,
            relatedEntities: [{
              type: 'product',
              id: item.product_id,
              name: item.products.name
            }],
            suggestedActions: [
              'Consider promotional pricing',
              'Review demand forecast',
              'Evaluate storage costs'
            ]
          })
        }
      }
    }

    return anomalies
  }

  private async detectOrderAnomalies(
    organizationId: string
  ): Promise<AnomalyAlert[]> {
    const anomalies: AnomalyAlert[] = []

    // Get recent orders
    const { data: recentOrders } = await this.supabase
      .from('orders')
      .select('*')
      .eq('organization_id', organizationId)
      .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString())

    if (!recentOrders) return anomalies

    // Detect order spikes
    const { data: historicalOrders } = await this.supabase
      .from('orders')
      .select('created_at')
      .eq('organization_id', organizationId)
      .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())

    if (historicalOrders) {
      const dailyOrderCounts = this.aggregateByDay(historicalOrders)
      const stats = this.calculateStats(dailyOrderCounts)
      const todayCount = recentOrders.length
      
      // Check if today's orders are anomalous
      if (todayCount > stats.mean + 2 * stats.stdDev) {
        anomalies.push({
          id: `order-spike-${new Date().toISOString()}`,
          type: 'order_spike',
          severity: 'info',
          title: 'Unusual Order Volume',
          description: `Today's order count (${todayCount}) is significantly higher than average (${stats.mean.toFixed(1)})`,
          detectedAt: new Date(),
          confidence: 0.85,
          relatedEntities: [],
          suggestedActions: [
            'Verify inventory availability',
            'Check for promotional campaigns',
            'Ensure fulfillment capacity'
          ]
        })
      }
    }

    // Detect unusual order patterns
    const largeOrders = recentOrders.filter(o => o.total > 10000)
    if (largeOrders.length > 0) {
      for (const order of largeOrders) {
        anomalies.push({
          id: `large-order-${order.id}`,
          type: 'large_order',
          severity: 'info',
          title: 'Large Order Detected',
          description: `Order #${order.order_number} for $${order.total.toLocaleString()}`,
          detectedAt: new Date(),
          confidence: 1.0,
          relatedEntities: [{
            type: 'order',
            id: order.id,
            name: order.order_number
          }],
          suggestedActions: [
            'Verify customer credit',
            'Confirm inventory availability',
            'Consider manual review'
          ]
        })
      }
    }

    return anomalies
  }

  private async detectPricingAnomalies(
    organizationId: string
  ): Promise<AnomalyAlert[]> {
    const anomalies: AnomalyAlert[] = []

    // Get recent price changes
    const { data: priceChanges } = await this.supabase
      .from('product_pricing_history')
      .select(`
        *,
        product:products(*)
      `)
      .eq('organization_id', organizationId)
      .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString())
      .order('created_at', { ascending: false })

    if (!priceChanges) return anomalies

    // Group by product
    const productPriceChanges = new Map<string, any[]>()
    priceChanges.forEach(change => {
      const changes = productPriceChanges.get(change.product_id) || []
      changes.push(change)
      productPriceChanges.set(change.product_id, changes)
    })

    // Detect anomalies
    for (const [productId, changes] of productPriceChanges) {
      // Multiple price changes
      if (changes.length > 3) {
        anomalies.push({
          id: `price-volatility-${productId}`,
          type: 'price_volatility',
          severity: 'warning',
          title: 'High Price Volatility',
          description: `${changes[0].product.name} has had ${changes.length} price changes in 7 days`,
          detectedAt: new Date(),
          confidence: 0.9,
          relatedEntities: [{
            type: 'product',
            id: productId,
            name: changes[0].product.name
          }],
          suggestedActions: [
            'Review pricing strategy',
            'Check competitor pricing',
            'Stabilize pricing to avoid customer confusion'
          ]
        })
      }

      // Large price changes
      for (let i = 1; i < changes.length; i++) {
        const priceChange = (changes[i].price - changes[i-1].price) / changes[i-1].price
        if (Math.abs(priceChange) > 0.2) {
          anomalies.push({
            id: `large-price-change-${changes[i].id}`,
            type: 'large_price_change',
            severity: 'warning',
            title: 'Significant Price Change',
            description: `${changes[0].product.name} price ${priceChange > 0 ? 'increased' : 'decreased'} by ${Math.abs(priceChange * 100).toFixed(0)}%`,
            detectedAt: new Date(),
            confidence: 1.0,
            relatedEntities: [{
              type: 'product',
              id: productId,
              name: changes[0].product.name
            }],
            suggestedActions: [
              'Verify price change was intentional',
              'Monitor sales impact',
              'Communicate change to sales team'
            ]
          })
        }
      }
    }

    return anomalies
  }

  private async calculateMonthsOfSupply(inventoryItem: any): Promise<number> {
    // Get average monthly demand
    const { data: orders } = await this.supabase
      .from('order_items')
      .select('quantity, created_at')
      .eq('product_id', inventoryItem.product_id)
      .gte('created_at', new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString())

    if (!orders || orders.length === 0) return 999 // No sales data

    const totalDemand = orders.reduce((sum, order) => sum + order.quantity, 0)
    const monthlyDemand = totalDemand / 3 // 3 months of data

    if (monthlyDemand === 0) return 999

    return inventoryItem.quantity / monthlyDemand
  }

  private aggregateByDay(data: any[]): number[] {
    const dailyCounts = new Map<string, number>()
    
    data.forEach(item => {
      const date = new Date(item.created_at).toISOString().split('T')[0]
      dailyCounts.set(date, (dailyCounts.get(date) || 0) + 1)
    })

    return Array.from(dailyCounts.values())
  }

  private calculateStats(values: number[]): {
    mean: number
    stdDev: number
    min: number
    max: number
  } {
    const mean = values.reduce((a, b) => a + b) / values.length
    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length
    const stdDev = Math.sqrt(variance)
    
    return {
      mean,
      stdDev,
      min: Math.min(...values),
      max: Math.max(...values)
    }
  }

  private async storeAnomalies(
    organizationId: string,
    anomalies: AnomalyAlert[]
  ): Promise<void> {
    const insights = anomalies.map(a => ({
      organization_id: organizationId,
      insight_type: 'alert',
      title: a.title,
      content: a.description,
      severity: a.severity,
      related_entities: a.relatedEntities,
      recommended_actions: a.suggestedActions,
      valid_until: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
    }))

    if (insights.length > 0) {
      await this.supabase
        .from('ai_insights')
        .insert(insights)
    }
  }
}
```

### Phase 7: AI Insights Dashboard

```tsx
// app/(dashboard)/insights/page.tsx
import { Suspense } from 'react'
import { createServerClient } from '@/lib/supabase/server'
import { AIService } from '@/lib/ai/ai-service'
import { DemandForecaster } from '@/lib/ai/demand-forecasting'
import { ReorderPointCalculator } from '@/lib/ai/reorder-suggestions'
import { PriceOptimizer } from '@/lib/ai/price-optimization'
import { AnomalyDetector } from '@/lib/ai/anomaly-detection'
import { InsightsSummary } from '@/components/features/insights/insights-summary'
import { DemandForecastChart } from '@/components/features/insights/demand-forecast-chart'
import { ReorderSuggestions } from '@/components/features/insights/reorder-suggestions'
import { PriceRecommendations } from '@/components/features/insights/price-recommendations'
import { AnomalyAlerts } from '@/components/features/insights/anomaly-alerts'
import { NaturalLanguageChat } from '@/components/features/insights/nl-chat'
import { InsightsSkeleton } from '@/components/features/insights/insights-skeleton'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { RefreshButton } from '@/components/features/insights/refresh-button'

export default async function InsightsPage() {
  const supabase = createServerClient()
  
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Unauthorized')

  const { data: profile } = await supabase
    .from('user_profiles')
    .select('organization_id')
    .eq('user_id', user.id)
    .single()

  if (!profile?.organization_id) throw new Error('No organization found')

  // Initialize AI services
  const aiService = new AIService()
  const forecaster = new DemandForecaster()
  const reorderCalculator = new ReorderPointCalculator()
  const priceOptimizer = new PriceOptimizer()
  const anomalyDetector = new AnomalyDetector()

  // Fetch latest insights from cache
  const [insights, predictions, anomalies] = await Promise.all([
    supabase
      .from('ai_insights')
      .select('*')
      .eq('organization_id', profile.organization_id)
      .eq('is_dismissed', false)
      .order('created_at', { ascending: false })
      .limit(20),
    
    supabase
      .from('ai_predictions')
      .select('*')
      .eq('organization_id', profile.organization_id)
      .gte('expires_at', new Date().toISOString())
      .order('created_at', { ascending: false }),
    
    supabase
      .from('ai_insights')
      .select('*')
      .eq('organization_id', profile.organization_id)
      .eq('insight_type', 'alert')
      .eq('is_dismissed', false)
      .order('created_at', { ascending: false })
      .limit(10)
  ])

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">AI-Powered Insights</h1>
          <p className="text-muted-foreground">
            Intelligent predictions and recommendations powered by machine learning
          </p>
        </div>
        
        <RefreshButton organizationId={profile.organization_id} />
      </div>

      <Suspense fallback={<InsightsSkeleton />}>
        {/* Summary Cards */}
        <InsightsSummary
          insights={insights.data || []}
          predictions={predictions.data || []}
        />

        {/* Anomaly Alerts */}
        {anomalies.data && anomalies.data.length > 0 && (
          <AnomalyAlerts alerts={anomalies.data} />
        )}

        {/* Detailed Insights Tabs */}
        <Tabs defaultValue="forecast" className="space-y-4">
          <TabsList className="grid w-full grid-cols-5">
            <TabsTrigger value="forecast">Demand Forecast</TabsTrigger>
            <TabsTrigger value="reorder">Reorder Points</TabsTrigger>
            <TabsTrigger value="pricing">Price Optimization</TabsTrigger>
            <TabsTrigger value="trends">Trend Analysis</TabsTrigger>
            <TabsTrigger value="chat">Ask AI</TabsTrigger>
          </TabsList>

          <TabsContent value="forecast" className="space-y-4">
            <DemandForecastChart
              organizationId={profile.organization_id}
              predictions={predictions.data?.filter(p => p.prediction_type === 'demand') || []}
            />
          </TabsContent>

          <TabsContent value="reorder" className="space-y-4">
            <ReorderSuggestions
              predictions={predictions.data?.filter(p => p.prediction_type === 'reorder') || []}
            />
          </TabsContent>

          <TabsContent value="pricing" className="space-y-4">
            <PriceRecommendations
              predictions={predictions.data?.filter(p => p.prediction_type === 'price') || []}
            />
          </TabsContent>

          <TabsContent value="trends" className="space-y-4">
            <TrendAnalysis
              organizationId={profile.organization_id}
              insights={insights.data?.filter(i => i.insight_type === 'trend') || []}
            />
          </TabsContent>

          <TabsContent value="chat" className="space-y-4">
            <NaturalLanguageChat
              organizationId={profile.organization_id}
            />
          </TabsContent>
        </Tabs>
      </Suspense>
    </div>
  )
}
```

### Phase 8: Natural Language Chat Component

```tsx
// components/features/insights/nl-chat.tsx
'use client'

import { useState } from 'react'
import { useChat } from 'ai/react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { ScrollArea } from '@/components/ui/scroll-area'
import { Avatar, AvatarFallback } from '@/components/ui/avatar'
import { Send, Loader2, Sparkles } from 'lucide-react'
import { cn } from '@/lib/utils'

interface NaturalLanguageChatProps {
  organizationId: string
}

export function NaturalLanguageChat({ organizationId }: NaturalLanguageChatProps) {
  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat({
    api: '/api/ai/chat',
    body: {
      organizationId
    },
    initialMessages: [
      {
        id: 'welcome',
        role: 'assistant',
        content: 'Hello! I\'m your AI assistant. I can help you understand your inventory data, identify trends, and make recommendations. What would you like to know?'
      }
    ]
  })

  const suggestedQuestions = [
    'What products should I reorder soon?',
    'Are there any pricing opportunities?',
    'What are my inventory trends this month?',
    'Which products are overstocked?',
    'Show me demand forecast for top products'
  ]

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Sparkles className="h-5 w-5" />
          AI Assistant
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <ScrollArea className="h-[500px] pr-4">
          <div className="space-y-4">
            {messages.map((message) => (
              <div
                key={message.id}
                className={cn(
                  'flex gap-3',
                  message.role === 'user' ? 'justify-end' : 'justify-start'
                )}
              >
                {message.role === 'assistant' && (
                  <Avatar>
                    <AvatarFallback>AI</AvatarFallback>
                  </Avatar>
                )}
                
                <div
                  className={cn(
                    'rounded-lg px-4 py-2 max-w-[80%]',
                    message.role === 'user'
                      ? 'bg-primary text-primary-foreground'
                      : 'bg-muted'
                  )}
                >
                  <p className="text-sm whitespace-pre-wrap">{message.content}</p>
                </div>

                {message.role === 'user' && (
                  <Avatar>
                    <AvatarFallback>You</AvatarFallback>
                  </Avatar>
                )}
              </div>
            ))}

            {isLoading && (
              <div className="flex gap-3">
                <Avatar>
                  <AvatarFallback>AI</AvatarFallback>
                </Avatar>
                <div className="bg-muted rounded-lg px-4 py-2">
                  <Loader2 className="h-4 w-4 animate-spin" />
                </div>
              </div>
            )}
          </div>
        </ScrollArea>

        {messages.length === 1 && (
          <div className="space-y-2">
            <p className="text-sm text-muted-foreground">Suggested questions:</p>
            <div className="flex flex-wrap gap-2">
              {suggestedQuestions.map((question) => (
                <Button
                  key={question}
                  variant="outline"
                  size="sm"
                  onClick={() => {
                    handleInputChange({ target: { value: question } } as any)
                    handleSubmit(new Event('submit') as any)
                  }}
                >
                  {question}
                </Button>
              ))}
            </div>
          </div>
        )}

        <form onSubmit={handleSubmit} className="flex gap-2">
          <Input
            value={input}
            onChange={handleInputChange}
            placeholder="Ask me anything about your business..."
            disabled={isLoading}
          />
          <Button type="submit" disabled={isLoading}>
            {isLoading ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              <Send className="h-4 w-4" />
            )}
          </Button>
        </form>
      </CardContent>
    </Card>
  )
}
```

### Phase 9: Edge Functions for AI Processing

```typescript
// supabase/functions/ai-insights/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { Configuration, OpenAIApi } from 'https://esm.sh/openai@3.2.1'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const { organizationId, type, params } = await req.json()

    // Initialize Supabase client
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    )

    // Initialize OpenAI
    const configuration = new Configuration({
      apiKey: Deno.env.get('OPENAI_API_KEY'),
    })
    const openai = new OpenAIApi(configuration)

    let result

    switch (type) {
      case 'generate-insights':
        result = await generateInsights(supabaseClient, openai, organizationId)
        break
      
      case 'demand-forecast':
        result = await generateDemandForecast(supabaseClient, organizationId, params)
        break
      
      case 'price-optimization':
        result = await optimizePricing(supabaseClient, openai, organizationId, params)
        break
      
      case 'anomaly-detection':
        result = await detectAnomalies(supabaseClient, organizationId)
        break
      
      default:
        throw new Error(`Unknown operation type: ${type}`)
    }

    return new Response(
      JSON.stringify({ success: true, data: result }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    )
  } catch (error) {
    return new Response(
      JSON.stringify({ success: false, error: error.message }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    )
  }
})

async function generateInsights(supabase: any, openai: any, organizationId: string) {
  // Fetch business data
  const [inventory, orders, metrics] = await Promise.all([
    supabase
      .from('inventory')
      .select('*, products(*)')
      .eq('organization_id', organizationId)
      .limit(100),
    
    supabase
      .from('orders')
      .select('*')
      .eq('organization_id', organizationId)
      .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())
      .limit(100),
    
    supabase
      .from('analytics_metrics')
      .select('*')
      .eq('organization_id', organizationId)
      .order('metric_date', { ascending: false })
      .limit(30)
  ])

  // Prepare context for AI
  const context = {
    inventorySummary: summarizeInventory(inventory.data),
    orderTrends: analyzeOrderTrends(orders.data),
    performanceMetrics: summarizeMetrics(metrics.data)
  }

  // Generate insights using OpenAI
  const completion = await openai.createChatCompletion({
    model: 'gpt-4',
    messages: [
      {
        role: 'system',
        content: `You are a business analyst AI for a B2B e-commerce company. 
                 Analyze the provided data and generate actionable insights.
                 Focus on inventory optimization, revenue opportunities, and operational efficiency.`
      },
      {
        role: 'user',
        content: `Analyze this business data and provide insights:
                 ${JSON.stringify(context)}
                 
                 Provide:
                 1. Executive summary
                 2. Key opportunities
                 3. Risk alerts
                 4. Recommended actions`
      }
    ],
    temperature: 0.7,
    max_tokens: 1000
  })

  const insights = parseInsights(completion.data.choices[0].message.content)

  // Store insights
  await supabase
    .from('ai_insights')
    .insert(insights.map((insight: any) => ({
      ...insight,
      organization_id: organizationId,
      created_at: new Date().toISOString()
    })))

  return insights
}

function summarizeInventory(inventory: any[]) {
  if (!inventory || inventory.length === 0) return {}
  
  return {
    totalProducts: inventory.length,
    totalValue: inventory.reduce((sum, i) => sum + (i.quantity * i.products?.unit_price || 0), 0),
    lowStockItems: inventory.filter(i => i.quantity < (i.reorder_point || 10)).length,
    outOfStockItems: inventory.filter(i => i.quantity === 0).length
  }
}

function analyzeOrderTrends(orders: any[]) {
  if (!orders || orders.length === 0) return {}
  
  const dailyOrders = new Map()
  orders.forEach(order => {
    const date = new Date(order.created_at).toISOString().split('T')[0]
    dailyOrders.set(date, (dailyOrders.get(date) || 0) + 1)
  })
  
  const counts = Array.from(dailyOrders.values())
  const avgDailyOrders = counts.reduce((a, b) => a + b, 0) / counts.length
  
  return {
    totalOrders: orders.length,
    avgDailyOrders,
    trend: calculateTrend(counts)
  }
}

function calculateTrend(values: number[]): string {
  if (values.length < 2) return 'stable'
  
  const firstHalf = values.slice(0, Math.floor(values.length / 2))
  const secondHalf = values.slice(Math.floor(values.length / 2))
  
  const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length
  const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length
  
  const change = (secondAvg - firstAvg) / firstAvg
  
  if (change > 0.1) return 'increasing'
  if (change < -0.1) return 'decreasing'
  return 'stable'
}

function summarizeMetrics(metrics: any[]) {
  if (!metrics || metrics.length === 0) return {}
  
  const latest = metrics[0]
  return {
    orderAccuracy: latest?.accuracy_rate || 0,
    syncPerformance: latest?.avg_latency_ms || 0,
    inventoryTurnover: latest?.turnover_rate || 0
  }
}

function parseInsights(aiResponse: string): any[] {
  // Parse structured insights from AI response
  // This is simplified - in production, use more robust parsing
  return [
    {
      insight_type: 'summary',
      title: 'Business Intelligence Summary',
      content: aiResponse,
      severity: 'info'
    }
  ]
}

// Additional functions for demand forecasting, price optimization, and anomaly detection would go here
```

### Phase 10: API Routes for AI Chat

```typescript
// app/api/ai/chat/route.ts
import { streamText } from 'ai'
import { openai } from '@ai-sdk/openai'
import { createServerClient } from '@/lib/supabase/server'

export async function POST(req: Request) {
  const { messages, organizationId } = await req.json()
  
  const supabase = createServerClient()
  
  // Verify user has access
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return new Response('Unauthorized', { status: 401 })
  }

  // Get context data
  const context = await getBusinessContext(supabase, organizationId)

  // Stream AI response
  const result = await streamText({
    model: openai('gpt-4o'),
    system: `You are an AI assistant for a B2B e-commerce business intelligence platform.
             You have access to the following business data:
             ${JSON.stringify(context)}
             
             Provide helpful, specific insights and recommendations based on this data.
             Be concise and actionable in your responses.`,
    messages,
    temperature: 0.7,
    maxTokens: 500
  })

  return result.toTextStreamResponse()
}

async function getBusinessContext(supabase: any, organizationId: string) {
  // Fetch relevant context for AI
  const [inventory, recentOrders, insights] = await Promise.all([
    supabase
      .from('inventory')
      .select('quantity, products(name, sku)')
      .eq('organization_id', organizationId)
      .order('quantity', { ascending: true })
      .limit(10),
    
    supabase
      .from('orders')
      .select('total, created_at')
      .eq('organization_id', organizationId)
      .order('created_at', { ascending: false })
      .limit(10),
    
    supabase
      .from('ai_predictions')
      .select('prediction_type, prediction_value, confidence_score')
      .eq('organization_id', organizationId)
      .order('created_at', { ascending: false })
      .limit(5)
  ])

  return {
    lowStockItems: inventory.data,
    recentOrdersSummary: {
      count: recentOrders.data?.length || 0,
      totalValue: recentOrders.data?.reduce((sum: number, o: any) => sum + o.total, 0) || 0
    },
    latestPredictions: insights.data
  }
}
```

## Implementation Validation

### Gate 1: AI Integration ✓
- [ ] Vercel AI SDK properly configured
- [ ] OpenAI API key secured in environment
- [ ] Streaming responses working
- [ ] Edge functions deployed
- [ ] Rate limiting implemented

### Gate 2: Forecasting Accuracy ✓
- [ ] ARIMA model producing reasonable forecasts
- [ ] LSTM model training successfully
- [ ] Ensemble predictions improving accuracy
- [ ] Confidence scores meaningful
- [ ] Historical data properly processed

### Gate 3: Recommendations Quality ✓
- [ ] Reorder points calculated correctly
- [ ] Price recommendations logical
- [ ] Anomaly detection catching real issues
- [ ] Natural language insights helpful
- [ ] Actions are specific and actionable

### Gate 4: Performance ✓
- [ ] AI responses under 3 seconds
- [ ] Forecasts cached appropriately
- [ ] Large datasets handled efficiently
- [ ] TensorFlow.js models optimized
- [ ] API costs managed

### Gate 5: User Experience ✓
- [ ] Insights presented clearly
- [ ] Charts interactive and informative
- [ ] Chat interface intuitive
- [ ] Loading states smooth
- [ ] Error messages helpful

## Key Decisions

1. **Vercel AI SDK**: Official SDK for AI integration with Next.js
2. **Multiple Forecasting Models**: Ensemble approach for better accuracy
3. **Edge Functions**: Keep API keys secure, reduce latency
4. **Caching Strategy**: Store predictions to reduce API costs
5. **Natural Language Interface**: Make insights accessible to all users

## Out of Scope (Future PRPs)
- Custom ML model training interface
- Computer vision for product recognition
- Voice interface for insights
- Automated action execution
- Multi-language support

## Quality Score: 9/10

This PRP provides comprehensive implementation details with:
- Complete AI service architecture
- Multiple forecasting algorithms (ARIMA, LSTM, Prophet-style)
- Intelligent reorder point calculations
- Dynamic price optimization
- Real-time anomaly detection
- Natural language chat interface
- Secure edge functions for API calls
- Full integration with existing analytics infrastructure

The implementation leverages cutting-edge AI technologies while maintaining practical business value.