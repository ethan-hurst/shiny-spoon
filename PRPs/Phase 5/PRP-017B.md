Fix the following issues. The issues can be from different files or can overlap on same lines in one file.

- In app/(dashboard)/customers/[id]/pricing/history/page.tsx around lines 57 to 63, the current try-catch block catches all errors and returns an empty history, which can hide critical issues such as authentication failures. Refine the error handling by checking the error type or status code inside the catch block; for example, handle authentication errors separately by triggering a redirect or showing a specific message, while other errors can still return an empty history or be logged accordingly. This ensures important errors are not silently ignored.

- In app/(dashboard)/integrations/shopify/page.tsx around lines 53 to 88, improve error handling when fetching integration by ID by logging the error or displaying a user-friendly message for errors other than "not found". Modify the code to check the error type and ensure that unexpected errors are logged or surfaced, instead of silently continuing with a null integration.

- In app/(dashboard)/integrations/shopify/setup/page.tsx around lines 22 to 31, the error handling for fetching the user profile does not distinguish between database errors and missing profiles. Update the code to check if the error is due to no profile found (e.g., handle a "not found" or empty result case separately) and redirect accordingly, while logging and handling genuine database errors differently, such as showing an error message or retrying, instead of redirecting immediately.

- In app/(dashboard)/monitoring/alerts/page.tsx around lines 37 to 46, the code logs an error when fetching alert rules fails but continues rendering without handling the undefined alertRules, which can cause runtime issues. Modify the code to handle the error by providing a fallback UI or an error message to display when rulesError is present, and prevent rendering components that depend on alertRules until valid data is available.

- In app/actions/bulk-operations.ts lines 223 to 253, the CSV generation does not properly escape quotes within cell values, which can break the CSV format if any cell contains quotes. To fix this, update the CSV generation logic to replace any double quotes in cell values with two double quotes before wrapping the cell in quotes. Alternatively, replace the manual CSV creation with a robust CSV library like csv-stringify to handle all escaping and formatting automatically.

- In app/actions/bulk-operations.ts around lines 103 to 119, the getBulkOperations function currently fetches a fixed limit of 50 bulk operations without pagination. Modify the function to accept pagination parameters such as page number and page size, then calculate the offset accordingly. Use the offset and limit in the Supabase query to fetch the correct subset of bulk operations, enabling proper pagination support.

- In app/actions/bulk-operations.ts lines 8 to 68, improve file validation by checking the file's MIME type or extension to ensure it is a CSV before processing. Confirm that the file passed to validateCSVFile is a proper File object compatible with the function's expectations. Replace unsafe type assertions like 'as File' and 'as string' with safer type checks or validations to prevent runtime errors and improve type safety.

- In app/actions/customer-pricing.ts around lines 128 to 134, the code updates a contract without verifying if the contract belongs to the user's organization, risking unauthorized updates. Before calling the update RPC, add a query to fetch the contract by ID including the related customer's organization_id, then check if the fetched contract exists and if its organization_id matches the user's organization_id. If not, throw an error to prevent unauthorized access. This ensures only contracts owned by the user's organization can be updated.

- In app/actions/customer-pricing.ts around lines 45 to 47, the current code calls parseInt on formData.get('renewal_period_months') without verifying if the value is non-null, which can cause parseInt to receive null or undefined and return NaN. To fix this, first retrieve the value from formData, check if it is a non-null string, then safely call parseInt on it; otherwise, set renewal_period_months to undefined.

- In app/actions/shopify-integration.ts around lines 152 to 153, avoid passing null for access_token and webhook_secret to prevent unintentionally clearing existing credentials. Instead, update the code to only include these fields in the update payload if they are explicitly provided in validatedData, or modify the RPC function to ignore null values so existing credentials remain unchanged when no new values are given.

- In app/api/bulk/progress/[operationId]/route.ts around lines 85 to 89, the if condition redundantly checks for operation.status === 'processing' twice. To fix this, simplify the condition to check if the status is 'processing' and then separately check if rollback has started within results. Adjust the condition to poll when the operation is processing or when rollback has started, avoiding repeated checks of the same status.

- In app/api/bulk/progress/[operationId]/route.ts around lines 18 to 28, the code fetches the operation by ID but does not verify if it belongs to the user's organization, risking unauthorized access. Modify the query to also filter by the user's organization ID, ensuring the operation belongs to the user's org. This requires adding an additional condition to the supabase query that matches the operation's organization ID with the user's organization ID before returning the operation or a 404 response.

- In app/api/bulk/rollback/route.ts at line 1, there is an import inconsistency where `createServerClient` is imported but `createClient()` is called in the code. To fix this, replace all calls to `createClient()` with `createServerClient()` to match the import and ensure consistent usage.

- In app/api/bulk/rollback/route.ts around lines 26 to 38, the code fetches the operation without verifying it belongs to the user's organization, risking unauthorized access. Fix this by adding a filter to the Supabase query to check that the operation's organization ID matches the user's organization ID before proceeding. If the organization IDs do not match, return a 403 Forbidden response to prevent unauthorized rollback actions.

- In app/api/bulk/upload/route.ts around lines 81 to 89, the current error handling returns raw error messages in the API response, which may expose sensitive information. Modify the code to sanitize error messages by returning a generic error message like "Internal server error" for all cases, avoiding sending the actual error.message in the response. Keep detailed error logging on the server side only.

- In app/api/bulk/upload/route.ts around lines 65 to 66, the use of 'as any' for operationType and entityType disables TypeScript's type checking, which is unsafe. Replace these casts by defining and using appropriate TypeScript types or enums for operationType and entityType, ensuring the variables conform to these types without using 'any'.

- In app/api/integrations/[id]/route.ts around lines 114 to 129, the error logging currently includes the full request body, which may expose sensitive information. Modify the logging to either remove the requestBody entirely or redact sensitive fields before logging. Ensure that no credentials or personal data are included in the logs to maintain security compliance.

- In app/api/integrations/[id]/route.ts between lines 30 and 52, the headers() function should be awaited if it returns a promise in the current Next.js version. Update the code to await headers() properly. Additionally, before calling crypto.timingSafeEqual, add a check to ensure both tokens have the same length to avoid runtime errors during comparison.

- In app/api/integrations/netsuite/health/route.ts around lines 361 to 400, the current code processes each integration sequentially, which can lead to slow execution and potential timeouts when handling many integrations. Refactor the loop to process integrations in parallel using Promise.all or a concurrency-limited queue to improve performance. Ensure you handle errors for each integration individually and collect results properly to maintain the existing behavior.

- In app/api/integrations/netsuite/health/route.ts around lines 303 to 310, replace the direct string comparison of the API key with a timing-safe comparison function to prevent timing attacks. Use a constant-time comparison method, such as Node.js's crypto.timingSafeEqual, by converting both keys to buffers before comparing. This ensures the comparison duration does not vary with input, enhancing security.

- In app/api/integrations/netsuite/health/route.ts around lines 207 to 221, the query fetching orphaned products may be expensive on large datasets. To fix this, first ensure there is a database index on the columns organization_id and external_id to speed up the query. Then, modify the query to include a limit on the number of records counted to reduce load. Finally, consider moving this counting operation to a background job if the exact count is not required in real-time health checks, to improve performance.

- In app/api/integrations/netsuite/test/route.ts around lines 115 to 118, the NetSuiteAPIClient is instantiated multiple times in the tests, causing unnecessary duplication. To fix this, move the creation of the apiClient instance to after line 71 so it is initialized once for all tests. Then update all test cases to reuse this single apiClient instance instead of creating new ones.

- In app/api/integrations/netsuite/test/route.ts around lines 237 to 242, the properties overall_status and message are assigned to the testResults object but are missing from the TestResults interface. To fix this, update the TestResults interface by adding overall_status as a string and message as a string to ensure type consistency and prevent TypeScript errors.

- In app/api/monitoring/alerts/[id]/acknowledge/route.ts around lines 94 to 98, the GET method lacks defensive parameter validation for the id parameter. Add validation to check if the id parameter exists and is valid before proceeding with the logic, similar to the validation implemented in the POST method. Return an appropriate error response if the validation fails.

- In app/api/monitoring/alerts/[id]/acknowledge/route.ts around lines 12 to 15, the id parameter from params is used without validation. Add defensive validation to check if id exists and is a valid string before proceeding. If invalid, return an appropriate error response to prevent runtime errors and ensure robustness.

- In app/api/monitoring/alerts/route.ts between lines 18 and 27, the code queries the organization_users table to get the user's organization, but other files use the user_profiles table for this purpose. To maintain consistency, change the query to select organization_id from the user_profiles table instead of organization_users, ensuring the rest of the query logic remains the same.

- In app/api/monitoring/alerts/route.ts around lines 124 to 127, the code uses type assertions for alert.status and alert.severity without runtime checks, which can cause errors if unexpected values are present. To fix this, add runtime validation to check if alert.status and alert.severity are valid keys of summary.byStatus and summary.bySeverity before incrementing. Use conditional checks or a type guard function to ensure safety before updating the summary counts.

- In components/features/bulk/bulk-operations-dashboard.tsx around lines 33 to 36, the state variable selectedOperation is declared but never used in the component. Remove the declaration and initialization of selectedOperation and its setter setSelectedOperation to clean up unused code and avoid confusion.

- In components/features/bulk/bulk-operations-dashboard.tsx around lines 209 to 223, the code only shows a toast notification when errors exist but does not provide a way to view the actual error details. Modify the Button's onClick handler to either open a modal or a new window displaying the error_log content, or trigger a download of the error log file, so users can access detailed error information directly instead of just seeing a notification.

- In components/features/bulk/bulk-progress-tracker.tsx around lines 109 to 125, the handleRollback function allows multiple rollback requests if triggered repeatedly. Add a guard at the start of the function to check if a rollback is already in progress (using isRollingBack state) and return early if true. This prevents sending multiple requests when the button is clicked multiple times quickly.

- In components/features/integrations/netsuite/netsuite-field-mappings.tsx around lines 218 to 232, the code accesses mapping.customSourceField and mapping.customTargetField without explicit null or undefined checks. To fix this, add explicit checks to ensure these custom fields are defined before using them, preventing potential runtime errors when these fields are missing or undefined.

- In components/features/integrations/netsuite/netsuite-sync-settings.tsx around lines 74 to 77, the current code converts arrays to comma-separated strings without checking if the values are already strings or filtering out empty values. Update the logic to first check if the config property is an array; if so, filter out any empty or falsy values before joining them with commas. If the property is already a string, use it as is. This will ensure robust handling of the input and prevent unexpected results.

- In components/features/integrations/netsuite/netsuite-sync-settings.tsx around lines 395 to 398, the onChange handler for the number input converts the input value to a Number without validating it, which can produce NaN for invalid inputs. Update the onChange function to first check if the input is a valid number before converting; if invalid, handle it gracefully by either setting an empty string or ignoring the change to prevent NaN values from being set.

- In components/features/integrations/netsuite/netsuite-sync-settings.tsx around lines 94 to 100, the current code splits comma-separated strings into arrays but does not validate the parsed values, potentially allowing empty or invalid entries. To fix this, add validation logic after splitting and trimming each string to ensure only valid, non-empty entries are included in the arrays for inventory_locations and price_levels. This can be done by enhancing the filter step to exclude invalid values based on the expected criteria.

- In components/features/integrations/netsuite/netsuite-sync-status.tsx around lines 186 to 190, the code assumes syncStates[0].last_sync_at always exists, which may cause errors if it is missing. Update the condition to check if syncStates[0] exists and has a valid last_sync_at before calling formatDistanceToNow. If last_sync_at is missing or invalid, display 'Never' instead to handle this edge case safely.

- In components/features/integrations/shopify/shopify-sync-status.tsx around lines 234 to 243, the progress calculation uses an arbitrary formula that does not reflect actual progress due to the lack of a total_records field. To fix this, either update the sync status data to include a total_records field for accurate progress calculation, or replace the current progress bar with an indeterminate progress indicator or remove it entirely while the sync is in progress.

- In components/features/monitoring/accuracy-analytics-dashboard.tsx around lines 512 to 515, avoid including error messages directly in the CSV output as it may confuse users or disrupt automated CSV processing. Instead of pushing an error message row to the CSV data, modify the catch block to either return an empty CSV string containing only the headers or rethrow the error so it can be handled by the calling function.

- In components/features/monitoring/accuracy-analytics-dashboard.tsx around lines 487 to 488, the CSV field escaping only replaces quotes but does not handle newlines or other special characters that can break the CSV format. Update the escaping logic to wrap fields containing quotes, newlines, or commas in double quotes and properly escape internal quotes by doubling them. This ensures all special characters are correctly handled for CSV compliance.

- In components/features/monitoring/accuracy-comparison-chart.tsx around lines 121 to 142, the CustomTooltip component uses 'any' for its props, which disables TypeScript type checking. Replace the 'any' type with appropriate TypeScript types for the tooltip props, such as defining an interface or using types from the charting library for active, payload, and label to ensure type safety and better code clarity.

- In components/features/monitoring/accuracy-comparison-chart.tsx between lines 42 and 96, the useEffect hook is missing the supabase client in its dependency array, which can cause stale closures. Add supabase to the dependency array to ensure the effect updates correctly. Additionally, improve error handling by introducing an error state variable to store error messages and display them to users instead of only logging errors to the console.

- In components/features/monitoring/alert-rules-list.tsx around lines 167 to 178, the property names used in rendering the table cells are in snake_case (accuracy_threshold, discrepancy_count_threshold, severity_threshold), but elsewhere in the component, including the handleToggleActive function, the camelCase versions (accuracyThreshold, discrepancyCountThreshold, severityThreshold) are expected. To fix this, update the property names in the JSX rendering to use camelCase consistently according to the AlertRule type definition, ensuring all references to these properties match the camelCase naming convention throughout the component.

- In components/features/monitoring/discrepancy-table.tsx around lines 152 to 158, the "View All Discrepancies" button is rendered but lacks an onClick handler or navigation logic, making it non-functional. Add an onClick handler to the Button that triggers navigation to the full discrepancies view, or replace the Button with a Link component pointing to the appropriate route for viewing all discrepancies. Ensure the handler or Link correctly integrates with the app's routing system.

- In components/features/pricing/contract-items-section.tsx around lines 77 to 85, the remove button lacks an aria-label, which reduces accessibility for screen reader users. Add an aria-label attribute to the Button component with a descriptive value such as "Remove item" to improve accessibility.

- In components/features/pricing/contract-items-section.tsx around lines 166 to 171, the code parses e.target.value to an integer without checking if the result is NaN, which can cause invalid values in the form state. Update the onUpdateItem call to validate the parsed integer by checking if it is a valid number; if it is NaN, pass undefined instead to avoid storing invalid values.

- In components/features/pricing/contract-list.tsx around lines 164 to 181, the date formatting logic is duplicated inside immediately invoked function expressions (IIFEs). Extract this logic into a single helper function named formatContractDate at the top of the component that takes a date string, parses it, and returns the formatted date or 'Invalid date' if parsing fails. Then replace the duplicated IIFEs in the JSX with calls to this helper function to improve maintainability and readability.

- In components/features/pricing/price-export-button.tsx at line 40, the filename uses customerName with only spaces replaced by underscores, which may allow unsafe special characters. Update the filename generation to sanitize customerName more thoroughly by removing or replacing all special characters that could cause security issues, ensuring the filename is safe for file systems and URLs.

- In components/features/pricing/price-export-button.tsx around lines 32 to 47, the URL object created with URL.createObjectURL(blob) is not revoked after the download, which can cause memory leaks. To fix this, call URL.revokeObjectURL(url) after the link.click() and before removing the link from the document body to properly release the allocated memory.

- In components/features/pricing/price-export-button.tsx around lines 26 to 58, the handleExport function lacks validation for the customerId input and has generic error handling. Add a check at the start of the function to ensure customerId is valid (e.g., not null or undefined) and if invalid, show a specific error toast and return early. Also, enhance the catch block to provide more detailed error messages by inspecting the error object and logging or displaying relevant information to aid debugging.

- In components/features/sync/sync-health-monitor.tsx around lines 277 to 281, the "Last updated" timestamp currently shows the current time on every render, which is misleading. To fix this, track the actual time when the health data was last fetched and display that stored timestamp instead of calling new Date().toLocaleTimeString() directly in the render. Update this timestamp only when the fetch occurs.

- In components/features/sync/sync-jobs-list.tsx around lines 78 to 99, the status parameter is currently cast to a union type using 'as', which is unsafe and can cause runtime errors if an invalid status is passed. Replace this with a proper type guard function that checks if the status is one of the allowed values before using it. Use this type guard to safely determine the variant from the variantMap and handle unknown statuses gracefully, avoiding direct casting.

- In components/features/sync/sync-schedule-dialog.tsx at line 184, the Dialog component allows closing even when submission or deletion operations are ongoing, which can confuse users. Modify the onOpenChange handler to check if a submission or deletion is in progress, and only call onClose() to close the dialog if no such operation is active. This prevents the dialog from closing during ongoing operations.

- In components/features/sync/sync-schedules-list.tsx around lines 137 to 141, replace the native browser confirm() call with a custom confirmation dialog component from your UI design system. Implement the dialog to prompt the user for confirmation before deleting a schedule, and handle the user's response to either proceed with or cancel the deletion. This will ensure consistent styling and a better user experience aligned with the rest of the application.

- In hooks/use-accuracy-monitor.ts at line 30, the Supabase client is created on every render, causing unnecessary overhead. Wrap the createClient() call inside a useMemo hook to memoize the client instance, ensuring it is only created once per component lifecycle or when dependencies change.

- In hooks/use-accuracy-monitor.ts around lines 125 to 127, the code incorrectly uses the camelCase property accuracyScore instead of the correct snake_case accuracy_score as defined in the database schema. Update the property access from payload.new.accuracyScore to payload.new.accuracy_score to match the database field name and avoid type mismatches.

- In hooks/use-customer-pricing.ts at line 175, replace the 'any' type for the 'payload' parameter with the appropriate type provided by Supabase to improve type safety. Identify the correct event or payload type from Supabase's types and use it instead of 'any' to ensure better type checking and code reliability.

- In hooks/use-customer-pricing.ts around lines 123 to 147, the async function checkExpiring runs on component mount but lacks cleanup to prevent memory leaks or state updates after unmount. Modify checkExpiring to track if the component is still mounted using a flag, and before updating state or query data, verify the component is mounted. Also, implement a cleanup function in the effect that sets this flag to false on unmount to cancel or ignore ongoing async operations.

- In hooks/use-customer-pricing.ts around lines 96 to 100, the subscribe() method's return status is not checked, which may miss subscription failures. Modify the code to capture the result of subscribe(), check if the subscription was successful, and handle errors appropriately by logging or throwing an error if the subscription fails.

- In hooks/use-netsuite-sync.ts at line 32, the Supabase client is created directly inside the hook, which can cause connection pooling issues by creating a new instance on each call. Refactor this by implementing a factory function or singleton pattern to create and reuse a single Supabase client instance across calls. Apply the same refactoring to the Supabase client creation in the useNetSuiteLogs hook around line 59 to ensure consistent client reuse.

- In hooks/use-netsuite-sync.ts around lines 104 to 124, the statistics calculation does not handle the case when syncStates is undefined, which can happen during loading or error states. To fix this, add a null check before calling reduce on syncStates, returning default stats with all counts set to zero if syncStates is undefined or null. This ensures the function always returns a valid stats object without errors.

- In lib/bulk/stream-processor.ts around lines 176 to 177, the processor function's return type is currently any[], which lacks specificity. Update the return type to an array of objects that include at least a boolean success property to match the expected structure used in statistics tracking. Define or use an appropriate interface or type that includes the success property and apply it as the return type of the processor function.

- In lib/bulk/stream-processor.ts around lines 41 to 45, the code maps headers to parsed data without checking if the data array length matches the headers length, which can cause errors with malformed CSV input. Add bounds checking to ensure that for each header, the corresponding data element exists before creating the key-value pair. Skip or handle missing data entries gracefully to avoid runtime errors.

- In lib/bulk/stream-processor.ts around lines 187 to 191, the progress stream is currently placed before batch processing, causing progress to be reported for parsed records instead of fully processed ones. To fix this, move the streamProcessor.createProgressStream(onProgress) call to after streamProcessor.createConcurrentProcessor(processor) in the pipeline so that progress tracking reflects actual processing completion.

- In lib/email/price-approval-notification.ts around lines 263 to 271, the current date parsing using a native Date constructor inside an IIFE may not reliably handle malformed or unexpected date strings despite the try-catch. To fix this, replace the native Date parsing with a more robust date parsing library like date-fns or moment, or add explicit validation of the date format before parsing. This ensures safer handling of edge cases and prevents potential runtime errors or invalid date outputs.

- In lib/integrations/auth-manager.ts around lines 477 to 489, the method currently returns null on errors while other methods throw exceptions, causing inconsistency. To fix this, modify the error handling to throw the caught error after logging it, aligning with the exception-throwing pattern used elsewhere, or alternatively add clear documentation explaining why this method returns null on errors to maintain clarity and consistency.

- In lib/integrations/auth-manager.ts around lines 280 to 283, the shop parameter used for URL substitution is not validated, which could lead to URL injection vulnerabilities. Add validation logic to ensure the shop parameter contains only allowed characters (e.g., alphanumeric and hyphens) before performing the replacement. If the validation fails, handle it appropriately by either throwing an error or skipping the substitution to maintain security.

- In lib/integrations/auth-manager.ts around lines 95 to 107, before performing the upsert on integration_credentials, add an access control check to verify that the caller has permission to modify credentials for the given integration_id. Implement a permission validation step that confirms the caller's authorization and only proceed with the upsert if the check passes, otherwise reject the operation to prevent unauthorized credential overwrites.

- In lib/integrations/encryption.ts around lines 332 to 338, the code incorrectly compares UTF-8 encoded hex string representations of signatures instead of their actual byte values, which can cause false negatives due to casing differences. To fix this, decode the hex strings into their raw byte arrays before using timingSafeEqual for comparison, ensuring the comparison is done on the actual signature bytes rather than their string encodings.

- In lib/integrations/netsuite/api-client.ts around lines 143 to 150, the rate limiter is released before checking if the response is ok, which is inconsistent with other CRUD methods. Move the rate limiter release to occur after the response.ok check and after handleApiError completes, ensuring the rate limiter is only released once error handling is done and maintaining consistent behavior across methods.

- In lib/integrations/netsuite/api-client.ts around lines 66 to 79, improve the limit and offset validation by first confirming NetSuite's actual maximum allowed limit and adjusting the upper bound accordingly instead of using 10,000. Also, ensure consistent casing by detecting the existing LIMIT/OFFSET keywords in the query and appending them in the same case (uppercase or lowercase) to avoid mixed casing in the final query string.

- In lib/integrations/netsuite/auth.ts at line 38, the environment variable used for the redirect URI is incorrectly named NEXT_PUBLIC_URL. Change it to NEXT_PUBLIC_APP_URL to maintain consistency with other components that use this environment variable name.

- In lib/integrations/netsuite/auth.ts around lines 274 to 283, the token revocation request is missing the Authorization header required for client authentication. Modify the fetch call to include an Authorization header with the client credentials, typically using Basic authentication with the client ID and client secret encoded in base64. This ensures the revocation request is properly authenticated by the NetSuite OAuth 2.0 endpoint.

- In lib/integrations/netsuite/connector.ts around lines 431 to 439, the use of .single() on the query can throw an error if no record is found, but the current code only checks if the result is truthy. To fix this, wrap the .single() call in a try-catch block to properly handle errors thrown when no record exists. Apply this error handling pattern similarly to the product query and in the updatePricing method to ensure all .single() calls handle missing records gracefully.

- In lib/integrations/netsuite/connector.ts at line 80, the condition `result.items.length >= 0` is always true and does not verify if the query executed successfully. Replace this condition with a proper check that confirms the query ran without errors, such as verifying the presence of items or a success status in the result object, to accurately reflect a successful connection test.

- In lib/integrations/netsuite/queries.ts around lines 484 to 490, the code handling the IN clause maps string values through a sanitizer but does not validate numeric values in the array, risking SQL injection. Update the mapping logic to validate numeric values explicitly, ensuring only safe numbers are included, and sanitize or reject any invalid or unexpected types before constructing the IN clause string.

- In lib/integrations/netsuite/queries.ts lines 41 to 60, improve the validateIdentifier method by making the reserved keywords check case-insensitive using a consistent lowercase comparison, expand the reserved keywords list to include more common SQL keywords like order, group, having, etc., and consider allowing reserved keywords as valid identifiers if they are properly quoted, adjusting the validation logic accordingly to support this behavior.

- In lib/integrations/netsuite/queries.ts lines 9 to 33, the sanitizeSqlValue method currently uses a blacklist approach to sanitize input, which can corrupt legitimate data and does not prevent SQL injection effectively. Replace this method to implement strict whitelist validation allowing only alphanumeric characters, spaces, underscores, and dashes. Instead of silently modifying input, throw an error immediately if disallowed characters are found. Additionally, refactor code to use the N/query module’s search.create API with filters for binding values instead of dynamic string interpolation wherever possible.

- In lib/integrations/netsuite/transformers.ts at line 141, the code uses parseFloat on item.baseprice without validating the result, which can produce NaN if the input is invalid. Update the code to check if the parsed value is a valid number using isNaN or a similar method, and only assign it to price if valid; otherwise, set price to undefined or handle the invalid case appropriately.

- In lib/integrations/shopify/bulk-operations.ts around lines 278 to 282, the GraphQL mutation uses direct string interpolation for IDs, which risks injection attacks. Refactor the mutation to use GraphQL variables instead of embedding values directly in the query string. Define variables for inventoryItemId, locationId, and delta in the mutation signature, then pass the actual values as a separate variables object to the API client to ensure safe parameterization.

- In lib/integrations/shopify/bulk-operations.ts between lines 44 and 66, the infinite while loop lacks a maximum retry count, risking indefinite execution if the bulk operation stalls. Introduce a retry counter variable initialized before the loop, increment it each iteration, and add a condition to break or throw an error when the retry count exceeds a defined maximum. This ensures the loop exits safely even if the operation status does not reach a terminal state.

- In lib/integrations/shopify/pricing-manager.ts around lines 44 to 56, the catalog save and price list sync operations are separate, risking inconsistency if price list sync fails after catalog save. To fix this, wrap both saveCatalog and syncPriceList calls within a transaction if supported by your data layer, or implement compensating actions such as rolling back the catalog save if price list sync fails. Ensure both operations succeed or fail together to maintain system consistency.

- In lib/integrations/shopify/transformers.ts around lines 366 to 376, the class uses this.locationMappings in getWarehouseId and isLocationMapped methods but does not declare the locationMappings property. To fix this, declare the locationMappings property in the class, specifying its type (e.g., a record or map from string to string or undefined) and initialize it appropriately to avoid runtime errors.

- In lib/integrations/webhook-handler.ts around lines 403 to 420, the generic webhook verifier uses a direct string comparison for one signature check, which is vulnerable to timing attacks. Replace this direct comparison with a timing-safe comparison method like crypto.timingSafeEqual to securely compare the signature values and prevent timing attack vulnerabilities.

- In lib/monitoring/accuracy-checker.ts around lines 431 to 433, the comment states that confidence weighting is applied to discrepancies, but the code does not implement any weighting and simply clamps the baseScore. To fix this, either remove or update the comment to accurately reflect the current implementation, or modify the code to apply a weighting factor based on confidence before clamping the score between 0 and 100.

- In lib/monitoring/accuracy-scorer.ts around lines 178 to 184, the code currently estimates records per entity type by dividing total records evenly, which can lead to inaccurate scoring. To fix this, replace the estimation with a query that fetches the actual count of records for each entity type from the database. Use these actual counts to calculate the entityScore for each entity type, ensuring the accuracy breakdown reflects real data distribution.

- In lib/monitoring/accuracy-scorer.ts between lines 38 and 44, the key 'product' in the ENTITY_WEIGHTS object is inconsistent with the rest of the codebase which uses 'products'. Rename the key from 'product' to 'products' to ensure naming consistency across the project.

- In lib/monitoring/alert-manager.ts around lines 285 to 287, the code uses a non-null assertion on rule.entityType which can cause runtime errors if entityType is null or undefined. To fix this, add a check to ensure rule.entityType is defined before calling includes on it, such as using optional chaining or an explicit conditional to safely handle cases where entityType might be null or undefined.

- In lib/monitoring/anomaly-detector.ts at line 416, the explanation string incorrectly uses changeRate > 1 to decide between 'increase' or 'decrease', but since changeRate is the absolute value, this always evaluates incorrectly. To fix this, replace the condition with a comparison between the current value and the historical value to determine the direction of change, then use that result to select 'increase' or 'decrease' in the explanation string.

- In lib/monitoring/auto-remediation.ts between lines 20 and 97, the remediation execution and subsequent status updates are separate operations that can lead to inconsistent data if one succeeds and the other fails. To fix this, wrap the remediation execution and all related database updates (inserting the log entry, updating the log with the result, and updating the discrepancy status) within a single database transaction to ensure atomicity. Use Supabase's transaction capabilities or equivalent to start a transaction before these operations and commit it only if all succeed, otherwise roll back to maintain data consistency.

- In lib/security/csrf.ts around lines 25 to 32, simplify the origin validation by directly comparing the origin header value with the host instead of reconstructing the expected origin from the origin URL's protocol and host. Remove the creation of expectedOrigin and just check if origin equals host or matches the required origin format directly.

- In supabase/migrations/010_shopify_integration.sql around lines 274 to 318, the SECURITY DEFINER function log_shopify_sync_activity lacks an explicit search_path setting, which can lead to schema hijacking vulnerabilities. To fix this, add a line at the start of the function body to set the search_path explicitly to a safe schema (e.g., 'public') before any other statements. This ensures the function runs with a controlled schema context and prevents malicious overrides.

- In supabase/migrations/012_sync_engine.sql at line 318, the JSON navigation syntax is incorrect because it chains the ->> operator, which is not allowed. To fix this, use the -> operator to access the nested JSON object first, then apply ->> to extract the text value from the inner key. Adjust the expression to properly navigate the JSON structure without chaining ->> operators.

- In supabase/migrations/012_sync_engine.sql around lines 189 to 223, the duration_ms calculation currently uses an INTEGER type and multiplies the epoch difference by 1000, which loses fractional seconds precision and risks overflow for long-running jobs. To fix this, change the duration_ms column type to BIGINT to support longer durations, and adjust the calculation to preserve fractional milliseconds by casting or rounding appropriately before assigning to duration_ms.

- In supabase/migrations/013_update_contract_items_rpc.sql around lines 26 to 32, the code directly casts JSONB fields without validating their presence or structure, which can cause runtime errors. Add checks to ensure each required JSONB field exists and is of the expected type before casting, using conditional expressions or JSONB functions to validate the structure and handle missing or malformed data gracefully.

- In supabase/migrations/014_create_shopify_integration_rpc.sql around lines 4 to 19, the function uses SECURITY DEFINER which can bypass row-level security, so you need to add input validation for parameters like p_shop_domain. Add checks at the start of the function to ensure p_shop_domain is not null or empty and matches the expected Shopify domain pattern using a regex. Also, review the function owner's privileges to ensure they are minimal and sanitize parameters to prevent injection risks.

- In supabase/migrations/014_update_contract_with_items_rpc.sql around lines 23 to 24, the direct casting of signed_date from JSONB to DATE can fail if the date string is invalid, causing the transaction to fail without clear errors. Replace the direct cast with a CASE statement that checks if the signed_date is NULL or empty string and returns NULL in those cases; otherwise, cast the value to DATE. This defensive approach prevents errors from invalid date strings during conversion.

- In supabase/migrations/014_update_contract_with_items_rpc.sql around lines 12 to 13, verify if SECURITY DEFINER is truly needed for this function to run with elevated privileges. If it is necessary, add a SET search_path clause at the start of the function body to explicitly define the schema search path and prevent search path injection attacks. Also confirm that the function owner has only the minimum required privileges to limit security risks.

- In supabase/migrations/20250127_add_organization_id_to_shopify_tables.sql around lines 112 to 116, the UPDATE statement may fail if webhook events reference deleted integrations. To fix this, modify the query to only update rows where the integration exists by ensuring the join condition filters out orphaned webhook events, for example by adding a condition that the integration id is not null or exists. This prevents errors during backfill by excluding webhook events with missing integrations.

- In types/netsuite.types.ts around lines 184 to 186, the isNetSuiteApiError type guard currently only checks for the presence of 'type' and 'status' properties, which may lead to false positives. Enhance the type guard by adding checks for additional specific properties unique to NetSuiteApiError, such as 'code' or 'message', to make the type guard more precise and robust.

- In types/shopify.types.ts around lines 328 to 333, the status enum values in the webhook schema are lowercase while the ShopifyProduct interface uses uppercase values, causing inconsistency. To fix this, update the z.enum in the webhook schema to use uppercase values ('ACTIVE', 'ARCHIVED', 'DRAFT') to match the interface, or alternatively, implement a case transformation in the webhook handler to convert incoming lowercase status values to uppercase before validation or usage.

- In types/shopify.types.ts around lines 416 to 446, the isShopifyProduct type guard is missing validation for the required fields handle, updatedAt, and createdAt, which should all be non-empty strings. Update the function to check that these fields exist and are strings, returning false if they are missing or not strings, to ensure the object fully conforms to the ShopifyProduct interface.