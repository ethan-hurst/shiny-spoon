# PRP-010: Pricing Rules Engine

## Goal

Build a sophisticated dynamic pricing system that calculates accurate B2B prices based on multiple factors including base pricing, customer tiers, quantity breaks, promotional periods, and custom overrides. This engine prevents pricing errors that cost distributors an average of $400k/year.

## Why

- **Revenue Protection**: Eliminate manual pricing errors and honor negotiated rates
- **Competitive Advantage**: React quickly to market changes with rule-based pricing
- **Customer Satisfaction**: Ensure customers always get their correct negotiated prices
- **Scalability**: Handle complex B2B pricing scenarios without manual intervention

## What

Create a rules-based pricing engine that evaluates multiple pricing factors in a defined precedence order, supports time-based promotions, handles quantity-based discounts, and provides a clear audit trail of how each price was calculated.

### Success Criteria

- [ ] Base product pricing with cost and margin tracking
- [ ] Customer tier-based automatic discounts
- [ ] Quantity break pricing with min/max quantities
- [ ] Date-ranged promotional pricing
- [ ] Customer-specific price overrides
- [ ] Price calculation API with explanation
- [ ] Bulk price updates with validation
- [ ] Price change history and audit trail
- [ ] Real-time price recalculation
- [ ] Integration with inventory for availability-based pricing

## All Needed Context

### Documentation & References

```yaml
- url: https://supabase.com/docs/guides/functions
  why: Edge functions for price calculation API

- url: https://www.postgresql.org/docs/current/sql-createfunction.html
  why: Database functions for price calculations

- file: types/customer.types.ts
  why: Customer tier structure from PRP-009

- url: https://ui.shadcn.com/docs/components/calendar
  why: Date range picker for promotions

- url: https://tanstack.com/table/latest/docs/guide/column-ordering
  why: Reorderable pricing rules table

- file: lib/csv/parser.ts
  why: Bulk import patterns from inventory

- url: https://supabase.com/docs/guides/database/postgres-policies#performance
  why: RLS performance for price queries

- docfile: docs/technical/caching-strategy.md
  why: Price calculation caching patterns
```

### Current Codebase Tree

```bash
truthsource/
├── app/
│   ├── (dashboard)/
│   │   ├── customers/
│   │   ├── inventory/
│   │   ├── products/
│   │   └── warehouses/
│   └── actions/
│       ├── customers.ts
│       ├── inventory.ts
│       ├── products.ts
│       └── warehouses.ts
├── types/
│   ├── customer.types.ts
│   ├── database.types.ts
│   └── inventory.types.ts
└── supabase/
    └── migrations/
```

### Desired Codebase Tree

```bash
truthsource/
├── app/
│   ├── (dashboard)/
│   │   └── pricing/
│   │       ├── page.tsx                    # Pricing rules dashboard
│   │       ├── loading.tsx
│   │       ├── rules/
│   │       │   ├── page.tsx               # All pricing rules
│   │       │   └── new/
│   │       │       └── page.tsx           # Create pricing rule
│   │       ├── promotions/
│   │       │   └── page.tsx               # Promotional pricing
│   │       └── calculator/
│   │           └── page.tsx               # Price testing tool
│   └── actions/
│       └── pricing.ts                      # Pricing actions
├── components/
│   └── features/
│       └── pricing/
│           ├── pricing-rules-table.tsx     # Rules management
│           ├── price-rule-form.tsx         # Create/edit rules
│           ├── quantity-breaks.tsx         # Quantity tier editor
│           ├── promotion-calendar.tsx      # Visual promotion view
│           ├── price-calculator.tsx        # Test calculations
│           ├── price-history.tsx           # Audit trail view
│           └── bulk-price-update.tsx       # Mass price changes
├── lib/
│   └── pricing/
│       ├── calculate-price.ts              # Core calculation logic
│       ├── pricing-engine.ts               # Rules evaluation
│       ├── cache.ts                        # Price caching
│       └── validations.ts                  # Price rule validation
├── types/
│   └── pricing.types.ts                    # Pricing types
└── supabase/
    ├── migrations/
    │   └── 005_pricing_rules.sql           # Pricing schema
    └── functions/
        └── calculate-price/
            └── index.ts                    # Edge function API
```

### Database Schema

```sql
-- Base product pricing
CREATE TABLE product_pricing (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  product_id UUID REFERENCES products(id) ON DELETE CASCADE NOT NULL,
  organization_id UUID REFERENCES organizations(id) NOT NULL,

  -- Base pricing
  cost DECIMAL(10,2) NOT NULL DEFAULT 0,
  base_price DECIMAL(10,2) NOT NULL,
  min_margin_percent DECIMAL(5,2) DEFAULT 20, -- Minimum acceptable margin

  -- Currency and units
  currency TEXT DEFAULT 'USD',
  pricing_unit TEXT DEFAULT 'EACH', -- EACH, CASE, PALLET, etc.
  unit_quantity INTEGER DEFAULT 1, -- How many items per pricing unit

  -- Metadata
  effective_date DATE DEFAULT CURRENT_DATE,
  expiry_date DATE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id)
);

-- Pricing rules with priority
CREATE TABLE pricing_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id) NOT NULL,

  -- Rule identification
  name TEXT NOT NULL,
  description TEXT,
  rule_type TEXT NOT NULL CHECK (rule_type IN ('tier', 'quantity', 'promotion', 'override')),
  priority INTEGER DEFAULT 100, -- Lower number = higher priority

  -- Rule conditions
  conditions JSONB NOT NULL DEFAULT '{}', -- Flexible conditions

  -- Rule actions
  discount_type TEXT CHECK (discount_type IN ('percentage', 'fixed', 'price')),
  discount_value DECIMAL(10,2),

  -- Applicability
  product_id UUID REFERENCES products(id), -- Null = all products
  category_id UUID REFERENCES product_categories(id), -- Null = all categories
  customer_id UUID REFERENCES customers(id), -- Null = all customers
  customer_tier_id UUID REFERENCES customer_tiers(id), -- Null = all tiers

  -- Status and dates
  is_active BOOLEAN DEFAULT true,
  start_date DATE,
  end_date DATE,

  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id)
);

-- Quantity break pricing
CREATE TABLE quantity_breaks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pricing_rule_id UUID REFERENCES pricing_rules(id) ON DELETE CASCADE,

  min_quantity INTEGER NOT NULL,
  max_quantity INTEGER, -- Null = no upper limit

  -- Price or discount for this quantity range
  discount_type TEXT CHECK (discount_type IN ('percentage', 'fixed', 'price')),
  discount_value DECIMAL(10,2) NOT NULL,

  -- Ordering
  sort_order INTEGER DEFAULT 0
);

-- Customer-specific pricing overrides
CREATE TABLE customer_pricing (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id UUID REFERENCES customers(id) ON DELETE CASCADE NOT NULL,
  product_id UUID REFERENCES products(id) ON DELETE CASCADE NOT NULL,
  organization_id UUID REFERENCES organizations(id) NOT NULL,

  -- Override pricing
  override_price DECIMAL(10,2),
  override_discount_percent DECIMAL(5,2),

  -- Contract details
  contract_number TEXT,
  contract_start DATE,
  contract_end DATE,

  -- Approval
  requires_approval BOOLEAN DEFAULT false,
  approved_by UUID REFERENCES auth.users(id),
  approved_at TIMESTAMPTZ,

  -- Metadata
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id),

  UNIQUE(customer_id, product_id)
);

-- Price calculation audit log
CREATE TABLE price_calculations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id) NOT NULL,

  -- Request details
  product_id UUID REFERENCES products(id) NOT NULL,
  customer_id UUID REFERENCES customers(id),
  quantity INTEGER NOT NULL,
  requested_at TIMESTAMPTZ DEFAULT NOW(),
  requested_by UUID REFERENCES auth.users(id),

  -- Calculation results
  base_price DECIMAL(10,2) NOT NULL,
  final_price DECIMAL(10,2) NOT NULL,
  total_discount DECIMAL(10,2) DEFAULT 0,
  margin_percent DECIMAL(5,2),

  -- Applied rules (for audit)
  applied_rules JSONB DEFAULT '[]',
  calculation_details JSONB DEFAULT '{}',

  -- Performance tracking
  calculation_time_ms INTEGER
);

-- Indexes for performance
CREATE INDEX idx_product_pricing_product ON product_pricing(product_id, organization_id);
CREATE INDEX idx_pricing_rules_active ON pricing_rules(organization_id, is_active) WHERE is_active = true;
CREATE INDEX idx_pricing_rules_dates ON pricing_rules(start_date, end_date);
CREATE INDEX idx_quantity_breaks_rule ON quantity_breaks(pricing_rule_id, min_quantity);
CREATE INDEX idx_customer_pricing_lookup ON customer_pricing(customer_id, product_id, organization_id);
CREATE INDEX idx_price_calculations_recent ON price_calculations(requested_at DESC);

-- Price calculation function
CREATE OR REPLACE FUNCTION calculate_product_price(
  p_product_id UUID,
  p_customer_id UUID,
  p_quantity INTEGER,
  p_requested_date DATE DEFAULT CURRENT_DATE
) RETURNS TABLE (
  base_price DECIMAL(10,2),
  final_price DECIMAL(10,2),
  discount_amount DECIMAL(10,2),
  applied_rules JSONB
) AS $$
DECLARE
  v_base_price DECIMAL(10,2);
  v_final_price DECIMAL(10,2);
  v_applied_rules JSONB := '[]'::JSONB;
  v_customer_tier_id UUID;
BEGIN
  -- Get base price
  SELECT base_price INTO v_base_price
  FROM product_pricing
  WHERE product_id = p_product_id
    AND (effective_date IS NULL OR effective_date <= p_requested_date)
    AND (expiry_date IS NULL OR expiry_date >= p_requested_date)
  ORDER BY effective_date DESC
  LIMIT 1;

  -- Start with base price
  v_final_price := v_base_price;

  -- Get customer tier if applicable
  IF p_customer_id IS NOT NULL THEN
    SELECT tier_id INTO v_customer_tier_id
    FROM customers
    WHERE id = p_customer_id;
  END IF;

  -- Apply pricing rules in priority order
  -- (Implementation continues with rule evaluation logic)

  RETURN QUERY
  SELECT
    v_base_price,
    v_final_price,
    v_base_price - v_final_price,
    v_applied_rules;
END;
$$ LANGUAGE plpgsql;
```

### Known Gotchas

```typescript
// CRITICAL: Price calculation order matters
// Example: 10% tier discount then $5 off vs $5 off then 10% discount
// Solution: Strict rule priority system

// CRITICAL: Overlapping date ranges can cause conflicts
// Example: Two promotions active for same product
// Solution: Priority field and "first match wins" logic

// CRITICAL: Quantity breaks need careful boundary handling
// Example: 1-10 units and 10-20 units - what happens at exactly 10?
// Solution: Use min_quantity with >= comparison

// CRITICAL: Currency conversion for international
// Example: USD base price but customer wants EUR
// Solution: Store exchange rates with effective dates

// CRITICAL: Performance with many rules
// Example: 1000s of customer-specific prices
// Solution: Indexed lookups and caching strategy

// CRITICAL: Margin protection on deep discounts
// Example: Stacked discounts exceed cost
// Solution: Minimum margin enforcement
```

## Implementation Blueprint

### Task List

```yaml
Task 1: Create Database Schema
CREATE supabase/migrations/005_pricing_rules.sql:
  - TABLES: All pricing tables with constraints
  - FUNCTIONS: calculate_product_price with full logic
  - INDEXES: Performance optimization
  - RLS: Organization-based isolation

Task 2: Create Pricing Types
CREATE types/pricing.types.ts:
  - INTERFACES: PricingRule, QuantityBreak, PriceCalculation
  - SCHEMAS: Zod validation for rules
  - ENUMS: Rule types, discount types
  - TYPES: API request/response types

Task 3: Build Pricing Engine
CREATE lib/pricing/pricing-engine.ts:
  - ENGINE: Rule evaluation logic
  - PRECEDENCE: Priority-based execution
  - STACKING: Handle multiple discounts
  - VALIDATION: Margin protection
CREATE lib/pricing/calculate-price.ts:
  - CALCULATE: Main price calculation
  - EXPLAIN: Return calculation steps
  - CACHE: Memoization for performance

Task 4: Create Pricing Dashboard
CREATE app/(dashboard)/pricing/page.tsx:
  - OVERVIEW: Active rules summary
  - STATS: Discount impact, margin analysis
  - ALERTS: Low margin warnings
  - QUICK: Common actions

Task 5: Build Rules Management
CREATE components/features/pricing/pricing-rules-table.tsx:
  - TABLE: All rules with filters
  - SORT: Drag-drop priority ordering
  - PREVIEW: Rule impact preview
  - ACTIONS: Edit, clone, deactivate
CREATE components/features/pricing/price-rule-form.tsx:
  - WIZARD: Step-by-step rule creation
  - CONDITIONS: Visual condition builder
  - PREVIEW: Test rule before saving

Task 6: Implement Quantity Breaks
CREATE components/features/pricing/quantity-breaks.tsx:
  - TIERS: Visual tier editor
  - VALIDATION: No gaps or overlaps
  - PREVIEW: Price curve visualization
  - IMPORT: From CSV template

Task 7: Build Promotion Manager
CREATE app/(dashboard)/pricing/promotions/page.tsx:
  - CALENDAR: Visual promotion timeline
  - CONFLICTS: Overlap detection
  - PREVIEW: Impact analysis
CREATE components/features/pricing/promotion-calendar.tsx:
  - VISUAL: Gantt-style view
  - DRAG: Adjust dates visually
  - FILTER: By product/category

Task 8: Create Price Calculator
CREATE app/(dashboard)/pricing/calculator/page.tsx:
  - TEST: Price calculation tool
  - EXPLAIN: Show applied rules
  - COMPARE: Multiple scenarios
CREATE components/features/pricing/price-calculator.tsx:
  - INPUTS: Product, customer, quantity
  - OUTPUT: Price with breakdown
  - HISTORY: Recent calculations

Task 9: Implement Server Actions
CREATE app/actions/pricing.ts:
  - RULES: CRUD operations
  - CALCULATE: Server-side price calc
  - BULK: Mass price updates
  - VALIDATE: Rule conflict checking

Task 10: Build Edge Function API
CREATE supabase/functions/calculate-price/index.ts:
  - API: RESTful price endpoint
  - BATCH: Multiple calculations
  - CACHE: Redis integration
  - AUTH: API key validation

Task 11: Add Real-time Updates
MODIFY hooks/use-inventory.ts:
  - SUBSCRIBE: Price rule changes
  - INVALIDATE: Clear price cache
  - UPDATE: Reflect new prices

Task 12: Create Import/Export
CREATE components/features/pricing/bulk-price-update.tsx:
  - TEMPLATE: Download current prices
  - UPLOAD: CSV with validation
  - PREVIEW: Changes before apply
  - ROLLBACK: Undo capability
```

### Pricing Engine Architecture

```typescript
// lib/pricing/pricing-engine.ts
export class PricingEngine {
  private rules: PricingRule[] = []
  private cache: Map<string, CachedPrice> = new Map()

  async calculatePrice(request: PriceRequest): Promise<PriceResponse> {
    const cacheKey = this.getCacheKey(request)

    // Check cache first
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey)!
      if (!this.isExpired(cached)) {
        return cached.response
      }
    }

    // Get applicable rules
    const applicableRules = await this.getApplicableRules(request)

    // Sort by priority
    const sortedRules = this.sortByPriority(applicableRules)

    // Apply rules in order
    let price = request.basePrice
    const appliedRules: AppliedRule[] = []

    for (const rule of sortedRules) {
      const result = await this.applyRule(rule, price, request)
      if (result.applied) {
        price = result.newPrice
        appliedRules.push(result.appliedRule)

        // Stop if exclusive rule
        if (rule.isExclusive) break
      }
    }

    // Enforce minimum margin
    price = this.enforceMinimumMargin(price, request.cost, request.minMargin)

    // Build response
    const response: PriceResponse = {
      basePrice: request.basePrice,
      finalPrice: price,
      discount: request.basePrice - price,
      discountPercent: ((request.basePrice - price) / request.basePrice) * 100,
      margin: ((price - request.cost) / price) * 100,
      appliedRules,
      calculatedAt: new Date(),
      ttl: 300, // 5 minute cache
    }

    // Cache result
    this.cache.set(cacheKey, {
      response,
      expiresAt: Date.now() + response.ttl * 1000,
    })

    return response
  }
}
```

### Rule Evaluation Logic

```typescript
// lib/pricing/rule-evaluator.ts
export class RuleEvaluator {
  evaluate(rule: PricingRule, context: PriceContext): boolean {
    // Check basic applicability
    if (!this.isActive(rule, context.date)) return false
    if (!this.matchesProduct(rule, context.productId)) return false
    if (!this.matchesCustomer(rule, context.customerId)) return false

    // Evaluate conditions
    return this.evaluateConditions(rule.conditions, context)
  }

  private evaluateConditions(
    conditions: RuleConditions,
    context: PriceContext
  ): boolean {
    // Quantity conditions
    if (conditions.minQuantity && context.quantity < conditions.minQuantity) {
      return false
    }

    // Customer conditions
    if (conditions.customerTiers && context.customerTier) {
      if (!conditions.customerTiers.includes(context.customerTier)) {
        return false
      }
    }

    // Product conditions
    if (conditions.productCategories && context.productCategory) {
      if (!conditions.productCategories.includes(context.productCategory)) {
        return false
      }
    }

    // Custom conditions (JSONB)
    if (conditions.custom) {
      return this.evaluateCustomConditions(conditions.custom, context)
    }

    return true
  }
}
```

## UI/UX Considerations

### Pricing Dashboard

- **KPI Cards**: Average discount %, margin %, active rules
- **Rule Summary**: Table of active rules with quick actions
- **Margin Alerts**: Highlight products below minimum margin
- **Quick Actions**: Create promotion, bulk update, calculator

### Rule Builder

- **Visual Builder**: Drag-drop conditions
- **Live Preview**: See impact as you build
- **Templates**: Common rule patterns
- **Validation**: Conflict warnings

### Price Calculator

- **Quick Test**: Single price calculation
- **Batch Test**: Upload CSV of scenarios
- **Comparison**: Side-by-side rule impact
- **Export**: Results to spreadsheet

### Promotion Calendar

- **Timeline View**: Visual overlap detection
- **Drag & Drop**: Adjust promotion dates
- **Impact Preview**: Estimated revenue impact
- **Quick Actions**: Extend, pause, clone

## Performance Considerations

1. **Caching Strategy**

   ```typescript
   // Redis for distributed cache
   // 5-minute TTL for calculated prices
   // Invalidate on rule changes
   // Warm cache for popular items
   ```

2. **Database Optimization**

   ```sql
   -- Materialized view for active rules
   CREATE MATERIALIZED VIEW active_pricing_rules AS
   SELECT * FROM pricing_rules
   WHERE is_active = true
     AND CURRENT_DATE BETWEEN COALESCE(start_date, '1900-01-01'::date)
     AND COALESCE(end_date, '2999-12-31'::date);

   -- Refresh periodically
   REFRESH MATERIALIZED VIEW CONCURRENTLY active_pricing_rules;
   ```

3. **Batch Processing**
   - Queue bulk updates
   - Process in chunks
   - Progress tracking
   - Rollback capability

## Security Considerations

1. **Access Control**
   - Role-based rule creation
   - Approval workflow for deep discounts
   - Audit trail for all changes

2. **Data Validation**
   - Prevent negative prices
   - Enforce margin minimums
   - Validate date ranges

3. **API Security**
   - Rate limiting on calculations
   - API key authentication
   - Request logging

## Testing Strategy

1. **Unit Tests**
   - Rule evaluation logic
   - Price calculations
   - Margin enforcement

2. **Integration Tests**
   - Multi-rule scenarios
   - Edge cases (0 quantity, expired rules)
   - Performance benchmarks

3. **E2E Tests**
   - Complete pricing workflow
   - Bulk update process
   - API endpoint testing

## Success Metrics

- < 50ms price calculation time
- 99.9% calculation accuracy
- Zero negative margin sales
- < 1% rule conflict rate
- 90% cache hit rate

## Dependencies

- **PRP-005**: Products (for base pricing)
- **PRP-009**: Customers (for tier pricing)
- **Redis**: For distributed caching
- **Edge Functions**: For API endpoint

## Next Steps

After PRP-010 is complete:

1. **PRP-011**: Customer-Specific Pricing UI
2. **PRP-016**: Real-time pricing sync
3. **PRP-020**: Pricing analytics dashboard
