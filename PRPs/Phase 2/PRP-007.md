# PRP-007: Inventory Management Core

## Goal
Build the core inventory management system that allows users to view current inventory levels by warehouse, make manual adjustments with reason tracking, view historical changes, set up low stock alerts, perform bulk updates via CSV, and export inventory data. This is the heart of preventing the 33% order error rate.

## Why
- **Business Value**: Direct impact on preventing $400k/year in order errors by maintaining accurate inventory data
- **Integration**: Foundation for real-time sync, automated reordering, and accurate order fulfillment
- **Problems Solved**: Eliminates manual spreadsheet tracking, provides audit trail for compliance, enables multi-location inventory visibility

## What
Create a comprehensive inventory management interface with real-time data display, adjustment capabilities with full audit trail, bulk operations support, and configurable alerts for low stock situations.

### Success Criteria
- [ ] View inventory levels filtered by warehouse with search
- [ ] Make inventory adjustments with mandatory reason selection
- [ ] View complete adjustment history with who/when/why
- [ ] Visual indicators for low stock (below reorder point)
- [ ] Bulk update inventory via CSV upload (up to 10,000 rows)
- [ ] Export current inventory to CSV with filters applied
- [ ] Mobile-responsive data tables with virtualization for performance
- [ ] Real-time updates when other users make changes

## All Needed Context

### Documentation & References
```yaml
- url: https://tanstack.com/table/latest/docs/introduction
  why: TanStack Table for advanced data grid features
  section: Virtualization for large datasets, sorting, filtering
  
- url: https://react-hook-form.com/docs/useform
  why: Form handling for adjustment dialog
  critical: Controller component for custom inputs
  
- file: components/features/products/product-table.tsx
  why: Pattern for data tables in our app (from PRP-005)
  
- url: https://ui.shadcn.com/docs/components/dialog
  why: Dialog pattern for inventory adjustments
  
- url: https://github.com/papaparse/papaparse
  why: CSV parsing for bulk import/export
  section: Browser-based parsing, streaming for large files

- docfile: docs/technical/supabase-integration-guide.md
  why: Real-time subscriptions pattern, RLS policies

- url: https://supabase.com/docs/guides/realtime/broadcast
  why: Real-time updates across users

- file: app/actions/products.ts
  why: Server Action patterns from PRP-005
```

### Current Codebase Tree
```bash
truthsource/
├── app/
│   ├── (dashboard)/
│   │   ├── layout.tsx
│   │   ├── products/        # From PRP-005
│   │   └── warehouses/      # From PRP-006
│   └── actions/
│       ├── products.ts
│       └── warehouses.ts
├── components/
│   ├── features/
│   │   ├── products/
│   │   └── warehouses/
│   └── ui/                  # All shadcn/ui components
├── lib/
│   └── supabase/
└── types/
    └── database.types.ts
```

### Desired Codebase Tree
```bash
truthsource/
├── app/
│   ├── (dashboard)/
│   │   └── inventory/
│   │       ├── page.tsx                    # Server Component main page
│   │       ├── loading.tsx                 # Loading skeleton
│   │       └── [id]/
│   │           └── history/
│   │               └── page.tsx            # Adjustment history for item
│   └── actions/
│       └── inventory.ts                    # Server Actions
├── components/
│   └── features/
│       └── inventory/
│           ├── inventory-table.tsx         # Main data table
│           ├── inventory-filters.tsx       # Warehouse/search filters  
│           ├── adjustment-dialog.tsx       # Adjustment form dialog
│           ├── adjustment-history.tsx      # History display
│           ├── bulk-upload-dialog.tsx      # CSV upload
│           ├── export-button.tsx           # CSV export
│           ├── low-stock-indicator.tsx     # Visual warning
│           └── inventory-stats.tsx         # Summary cards
├── hooks/
│   └── use-inventory.ts                    # Data fetching/mutations
├── lib/
│   ├── csv/
│   │   ├── parser.ts                      # CSV parsing utilities
│   │   └── templates.ts                   # CSV templates
│   └── inventory/
│       └── calculations.ts                 # Available qty logic
└── types/
    └── inventory.types.ts                  # Inventory-specific types
```

### Known Gotchas
```typescript
// CRITICAL: Inventory adjustments must be atomic transactions
// Example: Deducting inventory must check availability first
// Example: CSV uploads must validate all rows before processing any
// Example: Real-time updates can cause optimistic UI conflicts
// Example: Large CSV exports need streaming to avoid memory issues
// Example: Adjustment reasons are required for audit compliance
// Example: Available = on_hand - reserved, not just quantity
// Example: Table virtualization needed for 10k+ SKUs performance
// Example: Timezone handling for adjustment timestamps
```

## Implementation Blueprint

### Data Models and Structure
```typescript
// types/inventory.types.ts
import { z } from 'zod'
import { Database } from '@/types/database.types'

export type Inventory = Database['public']['Tables']['inventory']['Row']
export type Product = Database['public']['Tables']['products']['Row']
export type Warehouse = Database['public']['Tables']['warehouses']['Row']

export interface InventoryWithRelations extends Inventory {
  product: Product
  warehouse: Warehouse
}

export interface InventoryAdjustment {
  id: string
  inventory_id: string
  previous_quantity: number
  new_quantity: number
  adjustment: number
  reason: AdjustmentReason
  notes?: string
  created_at: string
  created_by: string
  user: {
    full_name: string
    email: string
  }
}

export type AdjustmentReason = 
  | 'sale'
  | 'return' 
  | 'damage'
  | 'theft'
  | 'found'
  | 'transfer_in'
  | 'transfer_out'
  | 'cycle_count'
  | 'other'

// Validation schemas
export const adjustmentSchema = z.object({
  inventory_id: z.string().uuid(),
  new_quantity: z.number().int().min(0).max(999999),
  reason: z.enum(['sale', 'return', 'damage', 'theft', 'found', 'transfer_in', 'transfer_out', 'cycle_count', 'other']),
  notes: z.string().max(500).optional(),
})

export const bulkUpdateSchema = z.object({
  updates: z.array(z.object({
    sku: z.string(),
    warehouse_code: z.string(),
    quantity: z.number().int().min(0),
    reason: z.enum(['cycle_count', 'other']),
  })).max(10000)
})

export interface InventoryFilters {
  warehouse_id?: string
  search?: string
  low_stock_only?: boolean
  category?: string
}

export interface InventoryStats {
  total_value: number
  total_items: number
  low_stock_items: number
  out_of_stock_items: number
}
```

### Task List

```yaml
Task 1: Install Dependencies
MODIFY package.json:
  - RUN: pnpm add @tanstack/react-table @tanstack/react-virtual
  - RUN: pnpm add papaparse @types/papaparse
  - RUN: pnpm add date-fns
  - RUN: pnpx shadcn-ui@latest add dialog table badge separator

Task 2: Create Database Migrations
CREATE supabase/migrations/003_inventory_adjustments.sql:
  - TABLE: inventory_adjustments with all audit fields
  - INDEX: On inventory_id and created_at
  - FUNCTION: Update inventory updated_at on change
  - RLS: Policies for organization isolation

Task 3: Create Inventory Page Structure
CREATE app/(dashboard)/inventory/page.tsx:
  - FETCH: Inventory with products and warehouses
  - FETCH: Warehouse list for filter
  - FETCH: Stats for summary cards
  - PASS: Data to client components

Task 4: Build Inventory Table Component
CREATE components/features/inventory/inventory-table.tsx:
  - USE: TanStack Table with virtualization
  - COLUMNS: SKU, Name, Warehouse, Available, Reserved, Reorder Point
  - FEATURES: Sort, search, row selection
  - ACTION: Adjust button per row

Task 5: Create Adjustment Dialog
CREATE components/features/inventory/adjustment-dialog.tsx:
  - FORM: Current qty (readonly), new qty, reason, notes
  - VALIDATE: New quantity different from current
  - CALCULATE: Adjustment amount (+/-)
  - SUBMIT: Via Server Action

Task 6: Implement Server Actions
CREATE app/actions/inventory.ts:
  - ACTION: adjustInventory with transaction
  - ACTION: bulkUpdateInventory with validation
  - ACTION: exportInventory returning CSV
  - PATTERN: Check permissions, validate, execute, log

Task 7: Add Real-time Subscriptions
CREATE hooks/use-inventory.ts:
  - SUBSCRIBE: To inventory changes for current org
  - UPDATE: Local state optimistically
  - ROLLBACK: On error
  - PATTERN: Follow products real-time pattern

Task 8: Build Bulk Upload Feature
CREATE components/features/inventory/bulk-upload-dialog.tsx:
  - PARSE: CSV with PapaParse
  - VALIDATE: All rows before processing
  - SHOW: Progress during upload
  - REPORT: Success/error summary

Task 9: Create Export Functionality
CREATE components/features/inventory/export-button.tsx:
  - GENERATE: CSV with current filters
  - STREAM: For large datasets
  - INCLUDE: All visible columns
  - FORMAT: Excel-friendly

Task 10: Add History View
CREATE app/(dashboard)/inventory/[id]/history/page.tsx:
  - SHOW: All adjustments for item
  - INCLUDE: User, timestamp, reason, notes
  - SORT: Most recent first
  - PAGINATE: 50 per page

Task 11: Create Stats Dashboard
CREATE components/features/inventory/inventory-stats.tsx:
  - CARDS: Total value, items, low stock, out of stock
  - REAL-TIME: Update with subscriptions
  - CLICKABLE: Filter table by stat

Task 12: Add Loading States
CREATE app/(dashboard)/inventory/loading.tsx:
  - SKELETON: Table structure
  - SHIMMER: Effect on cards
  - MATCH: Actual layout
```

### Pseudocode
```typescript
// Task 6: Server Actions
// app/actions/inventory.ts
'use server'

import { createServerClient } from '@/lib/supabase/server'
import { adjustmentSchema, bulkUpdateSchema } from '@/types/inventory.types'
import { revalidatePath } from 'next/cache'

export async function adjustInventory(formData: FormData) {
  const supabase = createServerClient()
  
  // Auth check
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Unauthorized')
  
  // Validate input
  const parsed = adjustmentSchema.safeParse({
    inventory_id: formData.get('inventory_id'),
    new_quantity: parseInt(formData.get('new_quantity') as string),
    reason: formData.get('reason'),
    notes: formData.get('notes'),
  })
  
  if (!parsed.success) {
    return { error: parsed.error.flatten() }
  }
  
  // CRITICAL: Use transaction for atomicity
  const { data: inventory } = await supabase
    .from('inventory')
    .select('quantity, product_id, warehouse_id')
    .eq('id', parsed.data.inventory_id)
    .single()
  
  if (!inventory) {
    return { error: 'Inventory item not found' }
  }
  
  const adjustment = inventory.quantity - parsed.data.new_quantity
  
  // Update inventory
  const { error: updateError } = await supabase
    .from('inventory')
    .update({ 
      quantity: parsed.data.new_quantity,
      updated_at: new Date().toISOString()
    })
    .eq('id', parsed.data.inventory_id)
  
  if (updateError) return { error: updateError.message }
  
  // Log adjustment
  const { error: logError } = await supabase
    .from('inventory_adjustments')
    .insert({
      inventory_id: parsed.data.inventory_id,
      previous_quantity: inventory.quantity,
      new_quantity: parsed.data.new_quantity,
      adjustment: adjustment,
      reason: parsed.data.reason,
      notes: parsed.data.notes,
      created_by: user.id
    })
  
  if (logError) {
    // ROLLBACK: Revert inventory change
    await supabase
      .from('inventory')
      .update({ quantity: inventory.quantity })
      .eq('id', parsed.data.inventory_id)
    
    return { error: 'Failed to log adjustment' }
  }
  
  revalidatePath('/inventory')