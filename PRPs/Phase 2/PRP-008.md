# PRP-008: Real-time Inventory Updates Enhancement

## Goal

Enhance the real-time inventory synchronization system with advanced features including optimistic updates with proper rollback, conflict resolution for simultaneous updates, connection status indicators, and offline queue support for updates when connection is lost.

## Why

- **Business Value**: Ensures multiple warehouse staff can work simultaneously without data conflicts
- **User Experience**: Provides immediate feedback and works seamlessly even with poor connectivity
- **Data Integrity**: Prevents lost updates and maintains consistency across all users
- **Reliability**: Handles network interruptions gracefully without losing work

## What

Build upon the existing real-time foundation to add production-ready features including visual connection status, offline support with queue management, conflict resolution UI, and enhanced optimistic updates with proper rollback mechanisms.

### Success Criteria

- [ ] Visual connection status indicator showing online/offline/reconnecting states
- [ ] Optimistic updates that feel instant with automatic rollback on failure
- [ ] Conflict resolution UI when simultaneous updates occur
- [ ] Offline queue that syncs when connection is restored
- [ ] Real-time presence showing who's viewing/editing inventory
- [ ] Performance monitoring for real-time connections
- [ ] Automatic reconnection with exponential backoff
- [ ] Network quality indicators (latency, stability)

## Implementation Details

### 1. Connection Status Management

```typescript
// lib/realtime/connection-manager.ts
export class RealtimeConnectionManager {
  private status: 'connected' | 'connecting' | 'disconnected' | 'error'
  private reconnectAttempts: number = 0
  private maxReconnectAttempts: number = 5
  private listeners: Set<(status: ConnectionStatus) => void>

  // Exponential backoff for reconnection
  private getReconnectDelay(): number {
    return Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000)
  }

  // Monitor connection quality
  public getConnectionQuality(): ConnectionQuality {
    return {
      latency: this.measureLatency(),
      stability: this.calculateStability(),
      throughput: this.measureThroughput(),
    }
  }
}
```

### 2. Offline Queue System

```typescript
// lib/realtime/offline-queue.ts
interface QueuedOperation {
  id: string
  type: 'UPDATE' | 'INSERT' | 'DELETE'
  table: string
  data: any
  timestamp: number
  retries: number
}

export class OfflineQueue {
  private queue: QueuedOperation[] = []
  private processing: boolean = false

  async addToQueue(operation: QueuedOperation): Promise<void> {
    // Store in IndexedDB for persistence
    await this.persistQueue()
  }

  async processQueue(): Promise<ProcessResult> {
    // Process operations in order with conflict detection
  }
}
```

### 3. Optimistic Updates with Rollback

```typescript
// hooks/use-optimistic-inventory.ts
export function useOptimisticInventory() {
  const [optimisticData, setOptimisticData] = useState()
  const [pendingUpdates, setPendingUpdates] = useState()

  const updateOptimistically = async (update: InventoryUpdate) => {
    // 1. Apply update immediately to UI
    // 2. Send to server
    // 3. Rollback on failure with user notification
    // 4. Handle conflicts with merge strategies
  }
}
```

### 4. Conflict Resolution UI

```typescript
// components/features/inventory/conflict-resolver.tsx
interface ConflictResolverProps {
  localValue: InventoryData
  serverValue: InventoryData
  onResolve: (
    resolution: 'local' | 'server' | 'merge',
    mergedValue?: InventoryData
  ) => void
}

export function ConflictResolver({
  localValue,
  serverValue,
  onResolve,
}: ConflictResolverProps) {
  // Show side-by-side comparison
  // Allow manual merge
  // Preview resolution result
}
```

### 5. Real-time Presence

```typescript
// hooks/use-inventory-presence.ts
interface PresenceData {
  userId: string
  userName: string
  avatarUrl?: string
  currentView: 'list' | 'item'
  itemId?: string
  lastActivity: Date
}

export function useInventoryPresence(inventoryId?: string) {
  // Show who's viewing/editing
  // Cursor positions for collaborative editing
  // Activity indicators
}
```

### 6. Performance Monitoring

```typescript
// lib/realtime/performance-monitor.ts
export class RealtimePerformanceMonitor {
  private metrics: PerformanceMetrics = {
    messageLatency: [],
    reconnectionCount: 0,
    messageDropRate: 0,
    subscriptionCount: 0,
  }

  public getHealthScore(): number {
    // Calculate overall health 0-100
  }

  public getRecommendations(): string[] {
    // Suggest optimizations based on metrics
  }
}
```

## Technical Architecture

### State Management

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│   UI Layer      │────▶│  Optimistic      │────▶│   Server        │
│                 │◀────│  State Layer     │◀────│   (Supabase)    │
└─────────────────┘     └──────────────────┘     └─────────────────┘
                               │                          │
                               ▼                          │
                        ┌──────────────────┐              │
                        │  Offline Queue   │◀─────────────┘
                        └──────────────────┘
```

### Message Flow

1. User makes change → Optimistic update applied
2. Change sent to server → If online, direct sync
3. If offline → Queue operation
4. On reconnect → Process queue with conflict detection
5. Conflicts → Show resolution UI
6. Resolution → Apply final state

## Migration Strategy

Since we already have basic real-time in PRP-007:

1. Enhance existing hooks with new features
2. Add connection management layer
3. Implement offline queue progressively
4. Add conflict resolution as needed
5. Monitor and optimize based on usage

## Performance Considerations

- Use connection pooling for multiple subscriptions
- Implement message batching for bulk updates
- Add debouncing for rapid changes
- Use IndexedDB for offline storage
- Implement virtual scrolling for presence lists

## Security Considerations

- Validate all optimistic updates server-side
- Implement rate limiting for real-time messages
- Ensure RLS policies apply to subscriptions
- Sanitize presence data before broadcasting
- Add subscription authentication

## Testing Strategy

1. Unit tests for offline queue
2. Integration tests for conflict resolution
3. E2E tests for real-time synchronization
4. Network simulation tests (slow, intermittent)
5. Load tests for multiple concurrent users

## Success Metrics

- < 100ms optimistic update latency
- < 5s reconnection time
- 0% data loss during offline periods
- < 1% conflict rate requiring manual resolution
- 99.9% real-time message delivery

## Implementation Blueprint

### Task List

```yaml
Task 1: Create Connection Management Infrastructure
CREATE lib/realtime/connection-manager.ts:
  - CONNECTION_STATUS: Types and interfaces
  - MANAGER: Singleton connection manager class
  - MONITOR: Connection quality monitoring
  - RETRY: Exponential backoff logic
CREATE lib/realtime/types.ts:
  - DEFINE: All shared types for real-time features

Task 2: Build Connection Status Component
CREATE components/features/inventory/realtime-indicator.tsx:
  - SHOW: Current connection status (green/yellow/red)
  - DISPLAY: Latency and stability metrics
  - ANIMATE: Pulse when receiving updates
  - TOOLTIP: Detailed connection info
MODIFY components/layout/header.tsx:
  - ADD: RealtimeIndicator to header

Task 3: Implement Offline Queue System
CREATE lib/realtime/offline-queue.ts:
  - QUEUE: Store operations when offline
  - PERSIST: Use IndexedDB for storage
  - PROCESS: Handle queue on reconnection
  - CONFLICT: Detect conflicting operations
CREATE lib/storage/indexed-db.ts:
  - WRAPPER: IndexedDB operations
  - SCHEMA: Define storage structure

Task 4: Enhance Optimistic Updates
CREATE hooks/use-optimistic-inventory.ts:
  - STATE: Manage optimistic state layer
  - APPLY: Immediate UI updates
  - ROLLBACK: Revert on failure
  - MERGE: Handle server responses
MODIFY components/features/inventory/inventory-table.tsx:
  - USE: Optimistic hook for updates
  - SHOW: Pending state indicators

Task 5: Build Conflict Resolution UI
CREATE components/features/inventory/conflict-resolver.tsx:
  - DIALOG: Show when conflicts detected
  - COMPARE: Side-by-side value display
  - MERGE: Manual merge interface
  - PREVIEW: Show resolution result
CREATE components/features/inventory/conflict-dialog.tsx:
  - WRAPPER: Dialog for resolver
  - ACTIONS: Accept/reject buttons

Task 6: Add Real-time Presence
CREATE hooks/use-inventory-presence.ts:
  - TRACK: User presence on items
  - BROADCAST: Current activity
  - DISPLAY: Active users list
CREATE components/features/inventory/presence-avatars.tsx:
  - SHOW: User avatars on items
  - TOOLTIP: User details
  - ANIMATE: Entrance/exit

Task 7: Implement Performance Monitoring
CREATE lib/realtime/performance-monitor.ts:
  - COLLECT: Performance metrics
  - ANALYZE: Calculate health score
  - REPORT: Generate insights
CREATE components/features/inventory/performance-widget.tsx:
  - DISPLAY: Health score
  - CHART: Latency over time
  - ALERT: Performance issues

Task 8: Add Network Quality Detection
CREATE lib/realtime/network-quality.ts:
  - MEASURE: Latency and jitter
  - DETECT: Connection type
  - ADAPT: Adjust behavior based on quality
MODIFY hooks/use-inventory.ts:
  - THROTTLE: Updates on poor connection
  - BATCH: Messages when appropriate

Task 9: Create Migration for Presence
CREATE supabase/migrations/004_presence_tracking.sql:
  - TABLE: presence_status
  - FUNCTION: Clean old presence
  - TRIGGER: Auto-cleanup

Task 10: Add E2E Tests
CREATE tests/e2e/realtime-inventory.spec.ts:
  - TEST: Real-time sync
  - TEST: Offline queue
  - TEST: Conflict resolution
  - TEST: Presence updates

Task 11: Add Connection Utilities
CREATE lib/realtime/connection-utils.ts:
  - HELPER: Check online status
  - HELPER: Format connection info
  - HELPER: Calculate metrics

Task 12: Documentation
CREATE docs/features/realtime-inventory.md:
  - EXPLAIN: Architecture
  - GUIDE: Usage patterns
  - TROUBLESHOOT: Common issues
```

### Component Structure

```typescript
// lib/realtime/connection-manager.ts
import { RealtimeChannel, RealtimeClient } from '@supabase/supabase-js'

export interface ConnectionStatus {
  state: 'connected' | 'connecting' | 'disconnected' | 'error'
  latency: number
  lastConnected: Date | null
  reconnectAttempts: number
  quality: 'excellent' | 'good' | 'fair' | 'poor'
}

export class ConnectionManager {
  private static instance: ConnectionManager
  private status: ConnectionStatus
  private listeners: Map<string, (status: ConnectionStatus) => void>
  private reconnectTimer: NodeJS.Timeout | null

  static getInstance(): ConnectionManager {
    if (!ConnectionManager.instance) {
      ConnectionManager.instance = new ConnectionManager()
    }
    return ConnectionManager.instance
  }

  subscribe(
    id: string,
    callback: (status: ConnectionStatus) => void
  ): () => void {
    this.listeners.set(id, callback)
    callback(this.status) // Initial status

    return () => {
      this.listeners.delete(id)
    }
  }

  private notifyListeners(): void {
    this.listeners.forEach((callback) => callback(this.status))
  }
}
```

### Database Schema

```sql
-- Presence tracking table
CREATE TABLE IF NOT EXISTS presence_status (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  organization_id UUID REFERENCES organizations(id) NOT NULL,
  resource_type TEXT NOT NULL, -- 'inventory_list', 'inventory_item'
  resource_id TEXT, -- Optional: specific item ID
  status TEXT NOT NULL DEFAULT 'active',
  metadata JSONB DEFAULT '{}',
  last_seen TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for queries
CREATE INDEX idx_presence_org_resource ON presence_status(organization_id, resource_type, resource_id);
CREATE INDEX idx_presence_last_seen ON presence_status(last_seen);

-- Auto-cleanup old presence
CREATE OR REPLACE FUNCTION cleanup_old_presence()
RETURNS void AS $$
BEGIN
  DELETE FROM presence_status
  WHERE last_seen < NOW() - INTERVAL '5 minutes';
END;
$$ LANGUAGE plpgsql;

-- Schedule cleanup (requires pg_cron extension)
-- SELECT cron.schedule('cleanup-presence', '*/5 * * * *', 'SELECT cleanup_old_presence()');
```

### Integration Points

1. **Inventory Table Integration**
   - Add presence avatars to table rows
   - Show pending update indicators
   - Enable optimistic updates

2. **Header Integration**
   - Add connection status indicator
   - Show reconnection progress
   - Display connection quality

3. **Adjustment Dialog Integration**
   - Queue updates when offline
   - Show conflict resolution when needed
   - Indicate sync status

### Error Handling

```typescript
// lib/realtime/error-handler.ts
export class RealtimeErrorHandler {
  static handle(error: Error, context: string): void {
    console.error(`Realtime error in ${context}:`, error)

    if (error.message.includes('CONNECTION_ERROR')) {
      // Handle connection errors
    } else if (error.message.includes('CONFLICT')) {
      // Handle conflict errors
    } else if (error.message.includes('QUEUE_FULL')) {
      // Handle queue overflow
    }
  }
}
```

### Performance Optimizations

1. **Message Batching**

   ```typescript
   // Batch multiple updates within 100ms window
   const batchedUpdate = debounce(sendUpdate, 100, { maxWait: 500 })
   ```

2. **Subscription Pooling**

   ```typescript
   // Reuse channels for same table/filter combinations
   const channelPool = new Map<string, RealtimeChannel>()
   ```

3. **Lazy Loading**
   ```typescript
   // Only load presence for visible items
   const visiblePresence = useIntersectionObserver(itemRefs)
   ```

## Known Gotchas

```typescript
// CRITICAL: Handle race conditions in optimistic updates
// Example: User A and B update same item simultaneously
// Solution: Version numbers or timestamps for conflict detection

// CRITICAL: IndexedDB storage limits vary by browser
// Example: Safari has lower limits than Chrome
// Solution: Implement storage quota management

// CRITICAL: Supabase Realtime has connection limits
// Example: Too many subscriptions can hit limits
// Solution: Channel pooling and smart unsubscription

// CRITICAL: Network detection APIs aren't always reliable
// Example: navigator.onLine can give false positives
// Solution: Implement heartbeat/ping mechanism

// CRITICAL: Presence cleanup needs careful timing
// Example: User closes tab without cleanup
// Solution: Server-side cleanup with reasonable timeout
```

## UI/UX Considerations

### Connection Status Indicator

- **Green**: Connected, <100ms latency
- **Yellow**: Connected, 100-500ms latency
- **Red**: Disconnected or >500ms latency
- **Pulsing**: Receiving real-time updates
- **Spinning**: Reconnecting

### Optimistic Update Feedback

- **Instant**: Apply changes immediately
- **Pending**: Show subtle loading indicator
- **Success**: Brief checkmark animation
- **Failure**: Shake animation and revert
- **Conflict**: Highlight and show resolution

### Offline Mode

- **Banner**: "Working offline - changes will sync when connected"
- **Queue Badge**: Show number of pending changes
- **Sync Button**: Manual sync trigger
- **Progress**: Show sync progress when reconnecting

## Dependencies

- **PRP-007**: Basic inventory management must be complete
- **Supabase Realtime**: Requires Realtime enabled in Supabase
- **IndexedDB**: Modern browser support required
- **WebSocket**: For real-time connections

## Acceptance Criteria Checklist

- [ ] Connection status visible in UI at all times
- [ ] Updates feel instant (<100ms perceived latency)
- [ ] Conflicts show resolution UI, not errors
- [ ] Offline changes sync automatically on reconnect
- [ ] Can see who else is viewing/editing items
- [ ] Performance dashboard shows connection health
- [ ] Reconnects automatically with backoff
- [ ] Network quality affects sync behavior
- [ ] All changes eventually consistent
- [ ] No data loss in any network condition

## Sample Implementation Timeline

- **Day 1-2**: Connection management and status indicator
- **Day 3-4**: Offline queue and IndexedDB storage
- **Day 5-6**: Optimistic updates with rollback
- **Day 7-8**: Conflict resolution UI
- **Day 9-10**: Presence and performance monitoring
- **Day 11-12**: Testing and optimization

## Next Steps

After PRP-008 is complete:

1. **PRP-009**: Customer Management (uses real-time for customer updates)
2. **PRP-010**: Pricing Rules Engine (real-time price updates)
3. **PRP-015**: Sync Engine Core (builds on real-time infrastructure)
