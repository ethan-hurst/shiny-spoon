# PRP-005: Products Management

## Goal
Implement complete CRUD functionality for the products catalog, including a searchable/filterable products list, forms for adding and editing products with validation, bulk import via CSV, category management, and proper image handling. This creates the foundation for inventory tracking and pricing rules.

## Why
- **Business Value**: Accurate product data is essential for preventing order errors and maintaining correct pricing
- **Integration**: Products are referenced by inventory, pricing, and orders - this is a core entity
- **Problems Solved**: Eliminates manual product data management, ensures SKU uniqueness per organization, enables bulk operations for large catalogs

## What
Build a comprehensive product management system with data table for viewing/searching products, forms for create/edit operations, CSV import for bulk additions, category management, image upload support, and soft delete functionality for data integrity.

### Success Criteria
- [ ] Products list displays with search, sort, and filter by category
- [ ] Add new product with all fields and validation
- [ ] Edit existing product preserving SKU history
- [ ] Soft delete products (mark inactive, don't remove)
- [ ] Bulk import products via CSV (up to 5000 rows)
- [ ] Export products to CSV
- [ ] Category management (add/edit/remove)
- [ ] Image upload with preview
- [ ] SKU uniqueness enforced per organization
- [ ] Mobile-responsive forms and tables

## All Needed Context

### Documentation & References
```yaml
- url: https://ui.shadcn.com/docs/components/data-table
  why: Data table patterns with tanstack/react-table
  section: Sorting, filtering, pagination examples
  
- url: https://react-hook-form.com/advanced-usage#ControlledComponents
  why: Complex form with file upload
  critical: Controller for file input
  
- file: app/(dashboard)/layout.tsx
  why: Dashboard layout wrapper from PRP-004
  
- url: https://supabase.com/docs/guides/storage/uploads
  why: File upload to Supabase Storage
  section: Direct client uploads, security policies
  
- file: types/database.types.ts
  why: Product table schema from PRP-002

- docfile: docs/product/PRD.md
  why: Product catalog requirements

- url: https://github.com/react-dropzone/react-dropzone
  why: Drag-and-drop file upload UX

- url: https://tanstack.com/table/v8/docs/examples/react/row-selection
  why: Bulk operations on selected rows
```

### Current Codebase Tree
```bash
truthsource/
├── app/
│   ├── (dashboard)/
│   │   ├── layout.tsx
│   │   └── page.tsx
│   └── actions/
│       └── auth.ts
├── components/
│   ├── layout/          # From PRP-004
│   └── ui/
├── lib/
│   ├── supabase/
│   └── constants/
└── types/
    └── database.types.ts
```

### Desired Codebase Tree
```bash
truthsource/
├── app/
│   ├── (dashboard)/
│   │   └── products/
│   │       ├── page.tsx                  # Products list page
│   │       ├── new/
│   │       │   └── page.tsx             # Add product page
│   │       ├── [id]/
│   │       │   └── edit/
│   │       │       └── page.tsx         # Edit product page
│   │       └── loading.tsx              # Loading skeleton
│   └── actions/
│       └── products.ts                  # Product server actions
├── components/
│   └── features/
│       └── products/
│           ├── products-table.tsx       # Data table component
│           ├── product-form.tsx         # Add/edit form
│           ├── product-filters.tsx      # Search and filters
│           ├── category-select.tsx      # Category dropdown
│           ├── bulk-import-dialog.tsx   # CSV import
│           ├── product-actions.tsx      # Row actions menu
│           └── image-upload.tsx         # Image upload field
├── hooks/
│   └── use-products.ts                  # Products data hook
├── lib/
│   ├── validations/
│   │   └── product.ts                  # Zod schemas
│   └── csv/
│       └── product-import.ts           # CSV parsing
└── types/
    └── product.types.ts                # Product-specific types
```

### Known Gotchas
```typescript
// CRITICAL: SKU must be unique per organization, not globally
// Example: Org A and Org B can both have SKU "WIDGET-001"
// Example: Soft delete means active=false, not DELETE FROM
// Example: Image uploads need storage bucket per organization
// Example: CSV import must validate all rows before inserting any
// Example: Categories are per-org, not global
// Example: Price must be decimal(12,2) for currency precision
// Example: Search should check both SKU and name
// Example: Export should respect current filters
```

## Implementation Blueprint

### Data Models and Structure
```typescript
// types/product.types.ts
import { z } from 'zod'
import { Database } from '@/types/database.types'

export type Product = Database['public']['Tables']['products']['Row']
export type ProductInsert = Database['public']['Tables']['products']['Insert']
export type ProductUpdate = Database['public']['Tables']['products']['Update']

// lib/validations/product.ts
export const productSchema = z.object({
  sku: z.string()
    .min(1, 'SKU is required')
    .max(50, 'SKU must be less than 50 characters')
    .regex(/^[A-Za-z0-9-_]+$/, 'SKU can only contain letters, numbers, hyphens, and underscores'),
  name: z.string()
    .min(1, 'Product name is required')
    .max(200, 'Name must be less than 200 characters'),
  description: z.string().max(1000).optional(),
  category: z.string().optional(),
  base_price: z.string()
    .regex(/^\d+(\.\d{1,2})?$/, 'Invalid price format')
    .transform((val) => parseFloat(val)),
  cost: z.string()
    .regex(/^\d+(\.\d{1,2})?$/, 'Invalid cost format')
    .transform((val) => parseFloat(val))
    .optional(),
  weight: z.string()
    .regex(/^\d+(\.\d{1,3})?$/, 'Invalid weight format')
    .transform((val) => parseFloat(val))
    .optional(),
  image: z.instanceof(File).optional().or(z.string().optional()),
})

export const bulkProductSchema = z.object({
  products: z.array(z.object({
    sku: z.string(),
    name: z.string(),
    description: z.string().optional(),
    category: z.string().optional(),
    base_price: z.number(),
    cost: z.number().optional(),
    weight: z.number().optional(),
  })).max(5000, 'Maximum 5000 products per import')
})

export interface ProductFilters {
  search?: string
  category?: string
  active?: boolean
  priceRange?: {
    min: number
    max: number
  }
}

export interface ProductWithStats extends Product {
  inventory_count: number
  total_quantity: number
  low_stock: boolean
}
```

### Task List

```yaml
Task 1: Create Product Pages Structure
CREATE app/(dashboard)/products/page.tsx:
  - Server Component
  - Fetch products with stats
  - Fetch categories for filter
  - Pass to client components
CREATE app/(dashboard)/products/new/page.tsx:
  - Server Component rendering form
CREATE app/(dashboard)/products/[id]/edit/page.tsx:
  - Fetch product by ID
  - 404 if not found or wrong org

Task 2: Build Products Table
CREATE components/features/products/products-table.tsx:
  - Use @tanstack/react-table
  - Columns: SKU, Name, Category, Price, Stock, Status
  - Sortable columns
  - Row selection for bulk ops
  - Row actions menu
  - Pagination

Task 3: Create Product Form Component
CREATE components/features/products/product-form.tsx:
  - React Hook Form with Zod
  - All product fields
  - Image upload preview
  - Loading state during submit
  - Success/error handling
  - Reusable for add/edit

Task 4: Implement Image Upload
CREATE components/features/products/image-upload.tsx:
  - Dropzone for drag & drop
  - Preview current/new image
  - File size validation (max 5MB)
  - Supported formats: jpg, png, webp
  - Upload to Supabase Storage

Task 5: Create Server Actions
CREATE app/actions/products.ts:
  - createProduct(formData)
  - updateProduct(id, formData)
  - deleteProduct(id) - soft delete
  - bulkImportProducts(csvData)
  - exportProducts(filters)

Task 6: Build Search and Filters
CREATE components/features/products/product-filters.tsx:
  - Search input with debounce
  - Category dropdown
  - Active/inactive toggle
  - Price range slider (future)
  - Clear filters button

Task 7: Implement Category Management
CREATE components/features/products/category-select.tsx:
  - Fetch existing categories
  - Allow new category creation
  - Autocomplete functionality
  - Category usage count

Task 8: Create Bulk Import Dialog
CREATE components/features/products/bulk-import-dialog.tsx:
  - CSV file upload
  - Download template button
  - Preview first 10 rows
  - Validation summary
  - Progress during import
  - Results summary

Task 9: Add Export Functionality
MODIFY products-table.tsx:
  - Export button
  - Export current view
  - Export all with filters
  - CSV format matching import

Task 10: Create Loading States
CREATE app/(dashboard)/products/loading.tsx:
  - Table skeleton
  - Consistent with actual layout

Task 11: Set Up Storage Bucket
ADD to Supabase:
  - Create 'products' bucket
  - Set up RLS policies
  - Organize by org_id/product_id

Task 12: Add Data Validation
ENHANCE server actions:
  - Check SKU uniqueness
  - Validate against schema
  - Handle duplicate imports
  - Transaction safety
```

### Pseudocode
```typescript
// Task 5: Server Actions
// app/actions/products.ts
'use server'

import { createServerClient } from '@/lib/supabase/server'
import { productSchema } from '@/lib/validations/product'
import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'

export async function createProduct(formData: FormData) {
  const supabase = createServerClient()
  
  // Auth check
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Unauthorized')
  
  // Get user's organization
  const { data: profile } = await supabase
    .from('user_profiles')
    .select('organization_id')
    .eq('user_id', user.id)
    .single()
  
  // Parse and validate
  const parsed = productSchema.safeParse({
    sku: formData.get('sku'),
    name: formData.get('name'),
    description: formData.get('description'),
    category: formData.get('category'),
    base_price: formData.get('base_price'),
    cost: formData.get('cost'),
    weight: formData.get('weight'),
    image: formData.get('image'),
  })
  
  if (!parsed.success) {
    return { error: parsed.error.flatten() }
  }
  
  // Handle image upload if present
  let imageUrl = null
  if (parsed.data.image instanceof File) {
    const fileExt = parsed.data.image.name.split('.').pop()
    const fileName = `${profile.organization_id}/${Date.now()}.${fileExt}`
    
    const { error: uploadError } = await supabase.storage
      .from('products')
      .upload(fileName, parsed.data.image)
    
    if (uploadError) {
      return { error: 'Failed to upload image' }
    }
    
    const { data: { publicUrl } } = supabase.storage
      .from('products')
      .getPublicUrl(fileName)
    
    imageUrl = publicUrl
  }
  
  // Check SKU uniqueness
  const { data: existing } = await supabase
    .from('products')
    .select('id')
    .eq('organization_id', profile.organization_id)
    .eq('sku', parsed.data.sku)
    .limit(1)
  
  if (existing && existing.length > 0) {
    return { error: 'SKU already exists' }
  }
  
  // Insert product
  const { data: product, error } = await supabase
    .from('products')
    .insert({
      organization_id: profile.organization_id,
      sku: parsed.data.sku,
      name: parsed.data.name,
      description: parsed.data.description,
      category: parsed.data.category,
      base_price: parsed.data.base_price,
      cost: parsed.data.cost,
      weight: parsed.data.weight,
      image_url: imageUrl,
    })
    .select()
    .single()
  
  if (error) {
    return { error: error.message }
  }
  
  revalidatePath('/products')
  redirect('/products')
}

// Task 3: Product Form
// components/features/products/product-form.tsx
'use client'

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { productSchema } from '@/lib/validations/product'
import { createProduct, updateProduct } from '@/app/actions/products'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form'
import { ImageUpload } from './image-upload'
import { CategorySelect } from './category-select'
import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { toast } from 'sonner'

interface ProductFormProps {
  product?: Product
}

export function ProductForm({ product }: ProductFormProps) {
  const [isSubmitting, setIsSubmitting] = useState(false)
  const router = useRouter()
  
  const form = useForm<z.infer<typeof productSchema>>({
    resolver: zodResolver(productSchema),
    defaultValues: {
      sku: product?.sku || '',
      name: product?.name || '',
      description: product?.description || '',
      category: product?.category || '',
      base_price: product?.base_price?.toString() || '',
      cost: product?.cost?.toString() || '',
      weight: product?.weight?.toString() || '',
    }
  })
  
  async function onSubmit(values: z.infer<typeof productSchema>) {
    setIsSubmitting(true)
    
    const formData = new FormData()
    Object.entries(values).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        if (value instanceof File) {
          formData.append(key, value)
        } else {
          formData.append(key, value.toString())
        }
      }
    })
    
    const action = product 
      ? updateProduct.bind(null, product.id)
      : createProduct
    
    const result = await action(formData)
    
    if (result?.error) {
      toast.error('Failed to save product')
      setIsSubmitting(false)
    } else {
      toast.success(product ? 'Product updated' : 'Product created')
      router.push('/products')
    }
  }
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <div className="grid gap-6 md:grid-cols-2">
          <FormField
            control={form.control}
            name="sku"
            render={({ field }) => (
              <FormItem>
                <FormLabel>SKU</FormLabel>
                <FormControl>
                  <Input 
                    {...field} 
                    disabled={!!product} // Can't change SKU after creation
                    placeholder="WIDGET-001"
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          
          <FormField
            control={form.control}
            name="name"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Product Name</FormLabel>
                <FormControl>
                  <Input {...field} placeholder="Premium Widget" />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>
        
        {/* Continue with other fields... */}
        
        <div className="flex gap-4">
          <Button
            type="submit"
            disabled={isSubmitting}
          >
            {isSubmitting ? 'Saving...' : product ? 'Update Product' : 'Create Product'}
          </Button>
          <Button
            type="button"
            variant="outline"
            onClick={() => router.push('/products')}
          >
            Cancel
          </Button>
        </div>
      </form>
    </Form>
  )
}
```

### Integration Points
```yaml
DATABASE:
  - constraints: SKU unique per organization
  - indexes: On SKU and name for search
  - soft delete: active boolean field
  
STORAGE:
  - bucket: 'products' with RLS
  - structure: {org_id}/{product_id}/{filename}
  - policies: Users can upload to their org
  
REALTIME:
  - subscribe: Product changes (future)
  - broadcast: Inventory updates
  
VALIDATION:
  - server: Always validate in actions
  - client: For better UX
  - import: Validate entire CSV first
```

## Validation Loop

### Level 1: Type and Lint Check
```bash
# Type checking
pnpm tsc --noEmit

# Linting
pnpm lint app/(dashboard)/products
pnpm lint components/features/products

# Expected: No errors
```

### Level 2: Component Tests
```typescript
// __tests__/products/product-form.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { ProductForm } from '@/components/features/products/product-form'

describe('ProductForm', () => {
  it('validates required fields', async () => {
    render(<ProductForm />)
    
    const submitButton = screen.getByRole('button', { name: /create product/i })
    fireEvent.click(submitButton)
    
    await waitFor(() => {
      expect(screen.getByText(/sku is required/i)).toBeInTheDocument()
      expect(screen.getByText(/product name is required/i)).toBeInTheDocument()
    })
  })
  
  it('validates SKU format', async () => {
    render(<ProductForm />)
    
    const skuInput = screen.getByLabelText(/sku/i)
    fireEvent.change(skuInput, { target: { value: 'Invalid SKU!' } })
    fireEvent.blur(skuInput)
    
    await waitFor(() => {
      expect(screen.getByText(/can only contain letters/i)).toBeInTheDocument()
    })
  })
})
```

### Level 3: E2E Flow Test
```typescript
// e2e/products.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Product Management', () => {
  test('can create a new product', async ({ page }) => {
    // Login first
    await loginAsTestUser(page)
    
    // Navigate to products
    await page.goto('/products')
    await page.click('text=Add Product')
    
    // Fill form
    await page.fill('input[name="sku"]', 'TEST-001')
    await page.fill('input[name="name"]', 'Test Product')
    await page.fill('textarea[name="description"]', 'Test description')
    await page.fill('input[name="base_price"]', '99.99')
    
    // Submit
    await page.click('button[type="submit"]')
    
    // Verify redirect and product appears
    await page.waitForURL('/products')
    await expect(page.locator('text=TEST-001')).toBeVisible()
  })
  
  test('prevents duplicate SKUs', async ({ page }) => {
    await loginAsTestUser(page)
    await page.goto('/products/new')
    
    // Try to create duplicate
    await page.fill('input[name="sku"]', 'TEST-001')
    await page.fill('input[name="name"]', 'Duplicate Product')
    await page.click('button[type="submit"]')
    
    // Should show error
    await expect(page.locator('text=SKU already exists')).toBeVisible()
  })
})
```

### Level 4: Manual Testing Checklist
```bash
# 1. Products List
- Table loads with data
- Search works (try SKU and name)
- Category filter works
- Sort columns work
- Pagination works

# 2. Add Product
- All fields validate properly
- Image upload shows preview
- Can select/create category
- SKU uniqueness enforced
- Redirects to list on success

# 3. Edit Product  
- Data loads correctly
- SKU field is disabled
- Changes save properly
- Image can be changed

# 4. Bulk Import
- Download template works
- Upload validates rows
- Shows preview
- Handles errors gracefully
- Imports successfully
```

## Final Validation Checklist
- [ ] TypeScript compiles without errors
- [ ] All forms validate properly
- [ ] SKU uniqueness enforced per organization
- [ ] Image upload works and shows in table
- [ ] Search filters products correctly
- [ ] Category filter works
- [ ] Bulk import handles 1000+ rows
- [ ] Export respects current filters
- [ ] Mobile responsive tables and forms
- [ ] Loading states appear during operations
- [ ] Error messages are user-friendly
- [ ] Soft delete marks inactive, doesn't remove

## Anti-Patterns to Avoid
- ❌ Don't allow SKU changes after creation - breaks references
- ❌ Don't hard delete products - use soft delete
- ❌ Don't trust client-side validation - always validate server-side
- ❌ Don't upload images without size limits
- ❌ Don't import CSV without validating all rows first
- ❌ Don't forget organization context in queries
- ❌ Don't show all products - paginate
- ❌ Don't cache product data too long - prices change