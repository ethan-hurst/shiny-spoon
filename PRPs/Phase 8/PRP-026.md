# PRP-026: Multi-ERP Support

## Goal
Implement comprehensive support for multiple Enterprise Resource Planning (ERP) systems, enabling seamless integration with SAP, Oracle NetSuite, Microsoft Dynamics 365, and other major ERP platforms through a unified adapter framework.

## Importance
- **Market Reach**: Support enterprises using different ERP systems
- **Data Unification**: Single source of truth across multiple ERPs
- **Flexibility**: Allow businesses to switch or use multiple ERPs
- **Competitive Advantage**: Few solutions offer true multi-ERP support
- **Enterprise Ready**: Critical for large-scale deployments

## What to Build

### Phase 1: Universal ERP Adapter Framework

#### 1.1 Base ERP Connector
```typescript
// lib/integrations/erp/base-erp-connector.ts
export abstract class BaseERPConnector<TConfig = any> {
  protected config: TConfig
  protected logger: Logger
  protected rateLimiter: RateLimiter
  protected cache: CacheManager
  
  abstract connect(): Promise<void>
  abstract disconnect(): Promise<void>
  abstract testConnection(): Promise<boolean>
  
  // Standard ERP operations
  abstract getProducts(params: ProductQuery): Promise<Product[]>
  abstract upsertProduct(product: Product): Promise<Product>
  abstract getInventory(params: InventoryQuery): Promise<Inventory[]>
  abstract updateInventory(updates: InventoryUpdate[]): Promise<void>
  abstract getOrders(params: OrderQuery): Promise<Order[]>
  abstract createOrder(order: Order): Promise<Order>
  abstract getCustomers(params: CustomerQuery): Promise<Customer[]>
  abstract upsertCustomer(customer: Customer): Promise<Customer>
  
  // Webhook/event support
  abstract subscribeToEvents(events: ERPEvent[]): Promise<void>
  abstract handleWebhook(payload: any): Promise<void>
  
  // Batch operations
  abstract bulkSync(entities: ERPEntity[]): Promise<BulkResult>
}
```

#### 1.2 ERP Registry
```typescript
// lib/integrations/erp/erp-registry.ts
export class ERPRegistry {
  private connectors = new Map<string, ERPConnectorFactory>()
  
  register(type: ERPType, factory: ERPConnectorFactory) {
    this.connectors.set(type, factory)
  }
  
  create(type: ERPType, config: any): BaseERPConnector {
    const factory = this.connectors.get(type)
    if (!factory) throw new Error(`Unknown ERP type: ${type}`)
    return factory(config)
  }
  
  getSupportedERPs(): ERPInfo[] {
    return Array.from(this.connectors.keys()).map(type => ({
      type,
      name: ERP_METADATA[type].name,
      icon: ERP_METADATA[type].icon,
      features: ERP_METADATA[type].features,
    }))
  }
}
```

### Phase 2: SAP Integration

#### 2.1 SAP Connector
```typescript
// lib/integrations/erp/sap/sap-connector.ts
export class SAPConnector extends BaseERPConnector<SAPConfig> {
  private client: SAPClient
  private odata: ODataClient
  
  async connect() {
    // SAP uses various protocols: RFC, OData, REST
    this.client = await SAPClient.create({
      ashost: this.config.host,
      sysnr: this.config.systemNumber,
      client: this.config.client,
      user: this.config.username,
      passwd: this.config.password,
      lang: this.config.language || 'EN',
    })
    
    // OData for modern APIs
    this.odata = new ODataClient({
      baseUrl: `${this.config.host}/sap/opu/odata/sap/`,
      auth: {
        username: this.config.username,
        password: this.config.password,
      },
    })
  }
  
  async getProducts(params: ProductQuery) {
    // Use BAPI for product master data
    const result = await this.client.call('BAPI_MATERIAL_GETLIST', {
      MATNRSELECTION: params.ids?.map(id => ({ MATERIAL: id })),
      PLANTSELECTION: params.plants?.map(p => ({ PLANT: p })),
    })
    
    return this.transformSAPProducts(result.MATNRLIST)
  }
  
  private transformSAPProducts(materials: any[]): Product[] {
    return materials.map(mat => ({
      id: mat.MATERIAL,
      sku: mat.MATERIAL,
      name: mat.MAKTX,
      description: mat.MAKTX_LONG,
      category: this.mapMaterialType(mat.MTART),
      unit: mat.MEINS,
      price: 0, // Price from different BAPI
      active: mat.LVORM !== 'X',
    }))
  }
}
```

#### 2.2 SAP-Specific Features
```typescript
// lib/integrations/erp/sap/sap-features.ts
export class SAPFeatures {
  // Material Requirements Planning (MRP)
  async getMRPData(materialId: string, plant: string) {
    const result = await this.client.call('BAPI_MATERIAL_MRP_LIST', {
      MATERIAL: materialId,
      PLANT: plant,
    })
    
    return {
      reorderPoint: result.MRP_ITEMS?.[0]?.REORDER_PT,
      safetyStock: result.MRP_ITEMS?.[0]?.SAFETY_STK,
      lotSize: result.MRP_ITEMS?.[0]?.LOT_SIZE,
      leadTime: result.MRP_ITEMS?.[0]?.PLND_DELIV,
    }
  }
  
  // Bill of Materials
  async getBOM(materialId: string, plant: string) {
    const result = await this.client.call('BAPI_MAT_BOM_READ', {
      MATERIAL: materialId,
      PLANT: plant,
      BOM_USAGE: '1', // Production BOM
    })
    
    return this.transformBOM(result.BOM_ITEM)
  }
}
```

### Phase 3: Oracle NetSuite Integration

#### 3.1 NetSuite Connector
```typescript
// lib/integrations/erp/netsuite/netsuite-connector.ts
export class NetSuiteConnector extends BaseERPConnector<NetSuiteConfig> {
  private restClient: NetSuiteRestClient
  private soapClient: NetSuiteSoapClient
  
  async connect() {
    // REST API for modern operations
    this.restClient = new NetSuiteRestClient({
      accountId: this.config.accountId,
      consumerKey: this.config.consumerKey,
      consumerSecret: this.config.consumerSecret,
      tokenId: this.config.tokenId,
      tokenSecret: this.config.tokenSecret,
    })
    
    // SOAP for complex operations
    this.soapClient = new NetSuiteSoapClient({
      endpoint: `https://${this.config.accountId}.suitetalk.api.netsuite.com`,
      applicationId: this.config.applicationId,
    })
  }
  
  async getProducts(params: ProductQuery) {
    // Use SuiteQL for efficient queries
    const query = `
      SELECT 
        id,
        itemid as sku,
        displayname as name,
        salesdescription as description,
        class as category,
        unitstype as unit,
        baseprice as price
      FROM item
      WHERE isinactive = 'F'
      ${params.modifiedAfter ? `AND lastmodifieddate >= '${params.modifiedAfter}'` : ''}
      ORDER BY itemid
      LIMIT ${params.limit || 1000}
    `
    
    const response = await this.restClient.suiteQL(query)
    return response.items.map(this.transformNetSuiteItem)
  }
}
```

#### 3.2 NetSuite Advanced Features
```typescript
// lib/integrations/erp/netsuite/netsuite-features.ts
export class NetSuiteFeatures {
  // Saved Search Support
  async runSavedSearch(searchId: string, filters?: any[]) {
    const search = await this.soapClient.get({
      recordType: 'savedSearch',
      internalId: searchId,
    })
    
    if (filters) {
      search.criteria.filters.push(...filters)
    }
    
    return await this.soapClient.search(search)
  }
  
  // Custom Records
  async getCustomRecords(recordType: string) {
    const query = `
      SELECT * FROM customrecord_${recordType}
      WHERE isinactive = 'F'
    `
    return await this.restClient.suiteQL(query)
  }
  
  // Multi-subsidiary support
  async getSubsidiaries() {
    return await this.restClient.get('/subsidiary')
  }
}
```

### Phase 4: Microsoft Dynamics 365 Integration

#### 4.1 Dynamics 365 Connector
```typescript
// lib/integrations/erp/dynamics365/dynamics-connector.ts
export class Dynamics365Connector extends BaseERPConnector<DynamicsConfig> {
  private client: DynamicsWebApi
  
  async connect() {
    this.client = new DynamicsWebApi({
      webApiUrl: `${this.config.instanceUrl}/api/data/v9.2/`,
      onTokenRefresh: async (dynamicsWebApi, callback) => {
        const token = await this.getAccessToken()
        callback(token)
      },
    })
  }
  
  private async getAccessToken() {
    const response = await fetch(
      `https://login.microsoftonline.com/${this.config.tenantId}/oauth2/v2.0/token`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
          grant_type: 'client_credentials',
          client_id: this.config.clientId,
          client_secret: this.config.clientSecret,
          scope: `${this.config.instanceUrl}/.default`,
        }),
      }
    )
    
    const data = await response.json()
    return data.access_token
  }
  
  async getProducts(params: ProductQuery) {
    const filter = this.buildODataFilter(params)
    const response = await this.client.retrieveMultipleRequest({
      collection: 'products',
      select: ['productid', 'productnumber', 'name', 'description', 'price'],
      filter,
      maxPageSize: params.limit || 1000,
    })
    
    return response.value.map(this.transformDynamicsProduct)
  }
}
```

### Phase 5: Universal Data Transformation

#### 5.1 Schema Mapping Engine
```typescript
// lib/integrations/erp/transformers/schema-mapper.ts
export class SchemaMapper {
  private mappings: Map<string, FieldMapping[]> = new Map()
  
  defineMapping(source: ERPType, target: 'unified', mapping: FieldMapping[]) {
    this.mappings.set(`${source}:${target}`, mapping)
  }
  
  transform<T>(source: ERPType, data: any, target: 'unified'): T {
    const mapping = this.mappings.get(`${source}:${target}`)
    if (!mapping) throw new Error(`No mapping found`)
    
    return this.applyMapping(data, mapping)
  }
  
  private applyMapping(data: any, mapping: FieldMapping[]): any {
    const result: any = {}
    
    for (const map of mapping) {
      const sourceValue = this.getNestedValue(data, map.source)
      
      if (map.transform) {
        result[map.target] = map.transform(sourceValue)
      } else {
        result[map.target] = sourceValue
      }
      
      // Handle required fields
      if (map.required && result[map.target] == null) {
        throw new Error(`Required field ${map.target} is missing`)
      }
      
      // Apply default values
      if (result[map.target] == null && map.default !== undefined) {
        result[map.target] = map.default
      }
    }
    
    return result
  }
}
```

#### 5.2 Standard Transformers
```typescript
// lib/integrations/erp/transformers/standard-transformers.ts
export const standardTransformers = {
  // Date transformations
  sapDateToISO: (sapDate: string) => {
    // SAP format: YYYYMMDD
    return `${sapDate.slice(0,4)}-${sapDate.slice(4,6)}-${sapDate.slice(6,8)}`
  },
  
  // Unit conversions
  convertUnit: (value: number, from: string, to: string) => {
    const conversions = {
      'EA:DZ': 12,
      'EA:CS': 24,
      'KG:LB': 2.20462,
    }
    const key = `${from}:${to}`
    return conversions[key] ? value * conversions[key] : value
  },
  
  // Status mappings
  mapStatus: (erpStatus: string, erpType: ERPType) => {
    const statusMaps = {
      SAP: { '': 'active', 'X': 'inactive', 'D': 'deleted' },
      NETSUITE: { 'F': 'active', 'T': 'inactive' },
      DYNAMICS: { 0: 'active', 1: 'inactive', 2: 'deleted' },
    }
    return statusMaps[erpType]?.[erpStatus] || 'unknown'
  },
}
```

### Phase 6: Multi-ERP Orchestration

#### 6.1 ERP Orchestrator
```typescript
// lib/integrations/erp/orchestrator.ts
export class ERPOrchestrator {
  private connectors: Map<string, BaseERPConnector> = new Map()
  private syncEngine: SyncEngine
  
  async addERP(id: string, type: ERPType, config: any) {
    const connector = this.registry.create(type, config)
    await connector.connect()
    await connector.testConnection()
    
    this.connectors.set(id, connector)
    
    // Setup sync for this ERP
    await this.syncEngine.registerSource(id, connector)
  }
  
  async syncAll() {
    const results = await Promise.allSettled(
      Array.from(this.connectors.entries()).map(([id, connector]) =>
        this.syncERP(id, connector)
      )
    )
    
    return this.consolidateResults(results)
  }
  
  private async syncERP(id: string, connector: BaseERPConnector) {
    const strategy = this.determineSyncStrategy(connector)
    
    switch (strategy) {
      case 'full':
        return await this.fullSync(id, connector)
      case 'incremental':
        return await this.incrementalSync(id, connector)
      case 'real-time':
        return await this.realtimeSync(id, connector)
    }
  }
}
```

#### 6.2 Conflict Resolution
```typescript
// lib/integrations/erp/conflict-resolver.ts
export class ConflictResolver {
  async resolve(conflicts: DataConflict[]): Promise<Resolution[]> {
    const resolutions: Resolution[] = []
    
    for (const conflict of conflicts) {
      const resolution = await this.determineResolution(conflict)
      resolutions.push(resolution)
      
      // Apply resolution
      await this.applyResolution(resolution)
    }
    
    return resolutions
  }
  
  private async determineResolution(conflict: DataConflict): Promise<Resolution> {
    // Check configured rules
    const rule = await this.findApplicableRule(conflict)
    
    if (rule) {
      return this.applyRule(rule, conflict)
    }
    
    // Default strategies
    switch (conflict.type) {
      case 'update_conflict':
        // Last write wins by default
        return {
          action: 'accept',
          source: conflict.sources.sort((a, b) => 
            b.timestamp.getTime() - a.timestamp.getTime()
          )[0],
          reason: 'last_write_wins',
        }
        
      case 'duplicate':
        // Merge duplicates
        return {
          action: 'merge',
          strategy: 'combine_fields',
          reason: 'duplicate_detected',
        }
        
      default:
        // Manual review required
        return {
          action: 'manual_review',
          reason: 'no_automatic_resolution',
        }
    }
  }
}
```

### Phase 7: Configuration UI

#### 7.1 ERP Setup Wizard
```tsx
// components/integrations/erp/erp-setup-wizard.tsx
export function ERPSetupWizard() {
  const [step, setStep] = useState(1)
  const [selectedERP, setSelectedERP] = useState<ERPType>()
  const [config, setConfig] = useState<any>({})
  
  const steps = [
    { title: 'Select ERP', component: <ERPSelector /> },
    { title: 'Configure Connection', component: <ERPConfigForm /> },
    { title: 'Map Fields', component: <FieldMapper /> },
    { title: 'Test Connection', component: <ConnectionTest /> },
    { title: 'Setup Sync', component: <SyncConfiguration /> },
  ]
  
  return (
    <Card>
      <CardHeader>
        <CardTitle>Add ERP System</CardTitle>
        <Progress value={(step / steps.length) * 100} />
      </CardHeader>
      
      <CardContent>
        <div className="mb-8">
          <Breadcrumb>
            {steps.map((s, i) => (
              <BreadcrumbItem key={i} active={i + 1 === step}>
                {s.title}
              </BreadcrumbItem>
            ))}
          </Breadcrumb>
        </div>
        
        {steps[step - 1].component}
      </CardContent>
      
      <CardFooter>
        <Button
          variant="outline"
          onClick={() => setStep(step - 1)}
          disabled={step === 1}
        >
          Previous
        </Button>
        <Button
          onClick={() => setStep(step + 1)}
          disabled={step === steps.length}
        >
          {step === steps.length ? 'Finish' : 'Next'}
        </Button>
      </CardFooter>
    </Card>
  )
}
```

#### 7.2 Field Mapping Interface
```tsx
// components/integrations/erp/field-mapper.tsx
export function FieldMapper({ erpType, onSave }) {
  const [mappings, setMappings] = useState<FieldMapping[]>([])
  
  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-medium">Field Mappings</h3>
        <Button size="sm" onClick={autoDetectMappings}>
          Auto-detect
        </Button>
      </div>
      
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>ERP Field</TableHead>
            <TableHead>System Field</TableHead>
            <TableHead>Transform</TableHead>
            <TableHead>Required</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {mappings.map((mapping, i) => (
            <TableRow key={i}>
              <TableCell>
                <Select value={mapping.source}>
                  {erpFields.map(field => (
                    <SelectItem key={field} value={field}>
                      {field}
                    </SelectItem>
                  ))}
                </Select>
              </TableCell>
              <TableCell>
                <Select value={mapping.target}>
                  {systemFields.map(field => (
                    <SelectItem key={field} value={field}>
                      {field}
                    </SelectItem>
                  ))}
                </Select>
              </TableCell>
              <TableCell>
                <Select value={mapping.transform}>
                  <SelectItem value="">None</SelectItem>
                  <SelectItem value="uppercase">Uppercase</SelectItem>
                  <SelectItem value="date">Date Format</SelectItem>
                  <SelectItem value="custom">Custom...</SelectItem>
                </Select>
              </TableCell>
              <TableCell>
                <Switch
                  checked={mapping.required}
                  onCheckedChange={(checked) => 
                    updateMapping(i, { required: checked })
                  }
                />
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  )
}
```

### Phase 8: Monitoring & Analytics

#### 8.1 Multi-ERP Dashboard
```tsx
// components/integrations/erp/multi-erp-dashboard.tsx
export function MultiERPDashboard() {
  const { data: erpSystems } = useERPSystems()
  const { data: syncStatus } = useSyncStatus()
  
  return (
    <div className="grid gap-6">
      {/* ERP System Overview */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        {erpSystems?.map(erp => (
          <Card key={erp.id}>
            <CardHeader className="flex flex-row items-center space-x-2">
              <img src={erp.icon} alt={erp.name} className="w-8 h-8" />
              <div>
                <CardTitle className="text-lg">{erp.name}</CardTitle>
                <CardDescription>{erp.type}</CardDescription>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Status</span>
                  <Badge variant={erp.connected ? 'success' : 'destructive'}>
                    {erp.connected ? 'Connected' : 'Disconnected'}
                  </Badge>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Last Sync</span>
                  <span className="text-sm">{formatRelative(erp.lastSync)}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Records</span>
                  <span className="text-sm">{erp.recordCount.toLocaleString()}</span>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
      
      {/* Sync Performance */}
      <Card>
        <CardHeader>
          <CardTitle>Sync Performance</CardTitle>
        </CardHeader>
        <CardContent>
          <SyncPerformanceChart data={syncStatus} />
        </CardContent>
      </Card>
      
      {/* Data Conflicts */}
      <Card>
        <CardHeader>
          <CardTitle>Data Conflicts</CardTitle>
          <CardDescription>
            {syncStatus?.conflicts.length || 0} conflicts require attention
          </CardDescription>
        </CardHeader>
        <CardContent>
          <ConflictsList conflicts={syncStatus?.conflicts} />
        </CardContent>
      </Card>
    </div>
  )
}
```

## Success Metrics

### Integration Coverage
- **ERP Support**: SAP, Oracle NetSuite, Dynamics 365 minimum
- **Feature Parity**: 90%+ core features across all ERPs
- **Data Accuracy**: 99.9%+ sync accuracy
- **Performance**: < 5 minute sync for 10k records

### Technical Metrics
- **Uptime**: 99.9% availability for sync services
- **Latency**: < 500ms API response time
- **Throughput**: 1000+ records/second processing
- **Error Rate**: < 0.1% sync failures

### Business Metrics
- **Time to Integration**: < 1 hour setup per ERP
- **Maintenance**: < 2 hours/month per connection
- **ROI**: 50%+ reduction in manual data entry
- **Accuracy**: 90%+ reduction in data discrepancies

## Testing Strategy

### Unit Tests
- Connector initialization and configuration
- Data transformation accuracy
- Error handling and retry logic
- Rate limiting compliance

### Integration Tests
- Live ERP connections (sandbox environments)
- End-to-end sync workflows
- Conflict resolution scenarios
- Performance under load

### E2E Tests
- Setup wizard flow
- Field mapping interface
- Sync monitoring dashboard
- Error recovery workflows