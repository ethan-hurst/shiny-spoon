# PRP-023: Performance Optimization

## Goal

Optimize application performance through strategic caching, lazy loading, code splitting, and CDN integration to ensure fast load times and smooth user experience at scale.

## Why This Matters

- **User Experience**: Fast load times directly impact user satisfaction and engagement
- **Scalability**: Performance optimizations enable handling more users with same resources
- **Cost Efficiency**: Reduced server load and bandwidth usage lower operational costs
- **SEO Benefits**: Page speed is a critical ranking factor for search engines
- **Conversion Rates**: Every 100ms of latency costs 1% in sales (Amazon study)

## What We're Building

A comprehensive performance optimization strategy including:

1. Multi-layer caching (Browser, CDN, API, Database)
2. Optimized asset delivery with Next.js Image and Font optimization
3. Code splitting and lazy loading for faster initial loads
4. API response caching with Redis
5. Database query optimization and connection pooling
6. Static generation for marketing pages
7. Progressive Web App (PWA) capabilities
8. Performance monitoring and alerting

## Context & References

### Codebase Patterns

- **Next.js App Router**: Built-in optimizations for streaming, partial pre-rendering
- **Server Components**: Already using React Server Components for reduced client bundle
- **Image Optimization**: `next/image` component for automatic optimization
- **Dynamic Imports**: Support for code splitting with `dynamic()`
- **Supabase Edge Functions**: For compute-intensive operations
- **TanStack Query**: Client-side caching already implemented

### External Documentation

- **Next.js Performance**: https://nextjs.org/docs/app/building-your-application/optimizing
- **Web Vitals**: https://web.dev/vitals/
- **Redis Documentation**: https://redis.io/docs/
- **Cloudflare Workers**: https://developers.cloudflare.com/workers/
- **Bundle Analyzer**: https://github.com/vercel/next.js/tree/canary/packages/next-bundle-analyzer
- **Lighthouse CI**: https://github.com/GoogleChrome/lighthouse-ci

## Implementation Blueprint

### Phase 1: Performance Baseline & Monitoring

```typescript
// lib/performance/metrics.ts
import { onCLS, onFID, onLCP, onFCP, onTTFB } from 'web-vitals'

export function initWebVitals() {
  onCLS(sendToAnalytics)
  onFID(sendToAnalytics)
  onLCP(sendToAnalytics)
  onFCP(sendToAnalytics)
  onTTFB(sendToAnalytics)
}

function sendToAnalytics(metric: any) {
  // Send to your analytics endpoint
  const body = JSON.stringify({
    name: metric.name,
    value: metric.value,
    delta: metric.delta,
    id: metric.id,
    url: window.location.href,
    timestamp: Date.now()
  })

  // Use sendBeacon or fetch with keepalive
  if (navigator.sendBeacon) {
    navigator.sendBeacon('/api/analytics/vitals', body)
  }
}
```

### Phase 2: Caching Strategy

```typescript
// lib/cache/redis-client.ts
import { Redis } from '@upstash/redis'

export const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
})

// Cache wrapper with TTL
export async function withCache<T>(
  key: string,
  fetcher: () => Promise<T>,
  ttl: number = 3600 // 1 hour default
): Promise<T> {
  // Try to get from cache
  const cached = await redis.get<T>(key)
  if (cached) return cached

  // Fetch fresh data
  const fresh = await fetcher()
  
  // Store in cache
  await redis.setex(key, ttl, JSON.stringify(fresh))
  
  return fresh
}
```

### Phase 3: API Route Optimization

```typescript
// app/api/products/route.ts
import { withCache } from '@/lib/cache/redis-client'
import { headers } from 'next/headers'

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const organizationId = headers().get('x-organization-id')
  
  // Cache key based on query params
  const cacheKey = `products:${organizationId}:${searchParams.toString()}`
  
  const products = await withCache(
    cacheKey,
    async () => {
      // Expensive database query
      return await fetchProducts(searchParams)
    },
    300 // 5 minute TTL for product listings
  )

  return Response.json(products, {
    headers: {
      'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=600',
    },
  })
}
```

### Phase 4: Database Query Optimization

```sql
-- Materialized views for complex queries
CREATE MATERIALIZED VIEW inventory_summary AS
SELECT 
  p.id,
  p.name,
  p.sku,
  COALESCE(SUM(i.quantity), 0) as total_quantity,
  COALESCE(SUM(i.quantity * p.price), 0) as total_value,
  COUNT(DISTINCT i.warehouse_id) as warehouse_count,
  MIN(i.quantity) as min_quantity,
  MAX(i.quantity) as max_quantity
FROM products p
LEFT JOIN inventory i ON p.id = i.product_id
GROUP BY p.id, p.name, p.sku;

-- Create indexes for common queries
CREATE INDEX idx_inventory_summary_sku ON inventory_summary(sku);
CREATE INDEX idx_inventory_summary_quantity ON inventory_summary(total_quantity);

-- Refresh materialized view periodically
CREATE OR REPLACE FUNCTION refresh_inventory_summary()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY inventory_summary;
END;
$$ LANGUAGE plpgsql;
```

### Phase 5: Bundle Optimization

```javascript
// next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})

module.exports = withBundleAnalyzer({
  experimental: {
    optimizePackageImports: ['@tremor/react', 'lucide-react', 'date-fns'],
  },
  
  // Optimize images
  images: {
    formats: ['image/avif', 'image/webp'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },

  // Split chunks strategically
  webpack: (config, { isServer }) => {
    if (!isServer) {
      config.optimization.splitChunks = {
        chunks: 'all',
        cacheGroups: {
          default: false,
          vendors: false,
          // Vendor chunk
          vendor: {
            name: 'vendor',
            chunks: 'all',
            test: /node_modules/,
            priority: 20,
          },
          // Common components
          common: {
            name: 'common',
            minChunks: 2,
            chunks: 'all',
            priority: 10,
            reuseExistingChunk: true,
            enforce: true,
          },
          // Separate large libraries
          tremor: {
            test: /[\\/]node_modules[\\/]@tremor[\\/]/,
            name: 'tremor',
            priority: 30,
          },
        },
      }
    }
    return config
  },
})
```

### Phase 6: Progressive Web App

```json
// public/manifest.json
{
  "name": "Inventory Management System",
  "short_name": "Inventory Pro",
  "description": "Professional inventory management solution",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#000000",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

### Phase 7: Service Worker for Offline Support

```typescript
// public/sw.js
const CACHE_NAME = 'inventory-v1'
const urlsToCache = [
  '/',
  '/offline',
  '/manifest.json',
  '/icons/icon-192x192.png',
]

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(urlsToCache))
  )
})

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        // Cache hit - return response
        if (response) {
          return response
        }

        return fetch(event.request).then((response) => {
          // Check if valid response
          if (!response || response.status !== 200 || response.type !== 'basic') {
            return response
          }

          // Clone the response
          const responseToCache = response.clone()

          caches.open(CACHE_NAME)
            .then((cache) => {
              cache.put(event.request, responseToCache)
            })

          return response
        })
      })
      .catch(() => {
        // Return offline page for navigation requests
        if (event.request.mode === 'navigate') {
          return caches.match('/offline')
        }
      })
  )
})
```

### Phase 8: Edge Function for Heavy Computations

```typescript
// supabase/functions/optimize-image/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

serve(async (req) => {
  const { url, width, height, quality } = await req.json()

  try {
    // Fetch original image
    const response = await fetch(url)
    const blob = await response.blob()

    // Use Cloudflare Image Resizing API or similar
    const optimizedUrl = `https://your-cdn.com/cdn-cgi/image/w=${width},h=${height},q=${quality}/${url}`

    return new Response(
      JSON.stringify({ optimizedUrl }),
      { headers: { 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    )
  }
})
```

## Performance Targets

### Core Web Vitals Goals
- **LCP (Largest Contentful Paint)**: < 2.5s
- **FID (First Input Delay)**: < 100ms
- **CLS (Cumulative Layout Shift)**: < 0.1
- **FCP (First Contentful Paint)**: < 1.8s
- **TTFB (Time to First Byte)**: < 600ms

### Bundle Size Targets
- **Initial JS**: < 200KB (gzipped)
- **Total JS**: < 500KB (gzipped)
- **CSS**: < 50KB (gzipped)
- **Fonts**: < 100KB (subset + preload)

### API Performance
- **P50 Response Time**: < 200ms
- **P95 Response Time**: < 500ms
- **P99 Response Time**: < 1000ms

## Testing Strategy

### Performance Testing Tools
1. **Lighthouse CI**: Automated performance testing in CI/CD
2. **WebPageTest**: Real-world performance testing
3. **Bundle Analyzer**: Monitor bundle size changes
4. **k6**: Load testing for APIs
5. **Chrome DevTools**: Performance profiling

### Monitoring
1. **Real User Monitoring (RUM)**: Track actual user experience
2. **Synthetic Monitoring**: Proactive performance checks
3. **Error Tracking**: Monitor performance-related errors
4. **Custom Dashboards**: Track business-specific metrics