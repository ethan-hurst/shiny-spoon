# TruthSource - Next.js + Supabase Project

You are working on TruthSource, a B2B e-commerce data accuracy platform that prevents order errors by synchronizing data between ERPs and e-commerce platforms.

## Tech Stack
- Next.js 14+ (App Router)
- TypeScript with strict mode
- Supabase (PostgreSQL, Auth, Realtime, Storage)
- Tailwind CSS + shadcn/ui
- React Query (TanStack Query)
- React Hook Form + Zod
- Vercel deployment

## Project Context
- Problem: 33% of B2B orders contain errors, costing $400k/year per distributor
- Solution: Real-time sync with 99.9% accuracy
- Users: IT Directors, E-commerce Managers, Operations Managers

## Critical Patterns

### File Structure
```
app/
├── (auth)/           # Public auth routes
├── (dashboard)/      # Protected dashboard routes
├── api/              # Webhook endpoints
└── actions/          # Server actions
components/
├── ui/               # shadcn/ui components
└── features/         # Feature-specific components
lib/
├── supabase/         # Supabase clients
└── utils/            # Helpers
```

### Server Components (Default)
```tsx
// app/(dashboard)/inventory/page.tsx
export default async function InventoryPage() {
  const supabase = createServerClient()
  const { data } = await supabase
    .from('inventory')
    .select('*, products(*)')
    .order('updated_at', { ascending: false })

  return <InventoryTable data={data} />
}
```

### Client Components (Interactive)
```tsx
'use client'

export function InventoryTable({ data }: Props) {
  // Interactive features here
}
```

### Server Actions
```typescript
'use server'

export async function updateInventory(formData: FormData) {
  const supabase = createServerClient()
  const { data: { user } } = await supabase.auth.getUser()
  
  // Validate with Zod
  const parsed = schema.parse(Object.fromEntries(formData))
  
  // Update with RLS
  const { error } = await supabase
    .from('inventory')
    .update(parsed)
    .eq('id', parsed.id)
    
  revalidatePath('/inventory')
}
```

### Supabase Patterns
```typescript
// Always check organization context
.eq('organization_id', user.organizationId)

// Use RLS for security
ALTER TABLE inventory ENABLE ROW LEVEL SECURITY;

// Real-time subscriptions in Client Components only
const channel = supabase
  .channel('changes')
  .on('postgres_changes', { event: '*', schema: 'public', table: 'inventory' }, handler)
  .subscribe()
```

## Critical Rules
1. ALWAYS use Server Components by default
2. ALWAYS check auth before mutations
3. ALWAYS use RLS policies on tables
4. ALWAYS validate with Zod schemas
5. NEVER log sensitive data
6. NEVER trust external input
7. NEVER query without organization context

## Common Imports
```typescript
import { createServerClient } from '@/lib/supabase/server'
import { createBrowserClient } from '@/lib/supabase/client'
import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import { z } from 'zod'
```

## Performance
- Use Server Components for data fetching
- Use React Query for client-side caching
- Use Suspense boundaries for loading states
- Use dynamic imports for code splitting
- Optimize images with next/image

## Security
- All tables must have RLS policies
- Filter by organization_id in every query
- Use Supabase Auth for authentication
- Validate all inputs with Zod
- Use CSRF protection on mutations

## Testing
- E2E tests with Playwright
- Component tests with React Testing Library
- Always test error states
- Test RLS policies separately

## Error Handling
```typescript
try {
  // operation
} catch (error) {
  if (error.code === '23505') {
    return { error: 'This SKU already exists' }
  }
  console.error('Operation failed:', error.message)
  return { error: 'Something went wrong' }
}
```

## Key Business Rules
- Inventory must sync within 30 seconds
- Pricing must include customer-specific rules
- All changes must be audited
- Multi-warehouse support required
- 99.9% accuracy target

Remember: This handles critical B2B data. Prioritize accuracy and security over speed.
